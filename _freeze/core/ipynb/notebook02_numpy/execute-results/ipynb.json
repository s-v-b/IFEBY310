{
  "hash": "2fa5b3d7bd5df2e41eb10e2b94c0e6b0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Introduction to `numpy`\"\ndate: \"`r Sys.Date()\"\n\njupyter: python3\n\nengine: jupyter\n---\n\n\n[`NumPy`](https://numpy.org) is the fundamental package for scientific computing with Python. It contains among other things:\n\n- a powerful [N-dimensional array object](https://numpy.org/doc/stable/user/basics.indexing.html)\n- (sophisticated) [broadcasting functions](https://numpy.org/doc/stable/user/basics.broadcasting.html)\n- tools for integrating C/C++ and Fortran code\n- useful [linear algebra](https://numpy.org/doc/stable/reference/routines.linalg.html), [Fourier transform](https://numpy.org/doc/stable/user/basics.indexing.html), and [random generation capabilities](https://numpy.org/doc/stable/reference/random/index.html)\n\nBesides its obvious scientific uses, `NumPy` can also be used as an efficient multi-dimensional container for general data. Arbitrary data-types can be defined. This allows `NumPy` to seamlessly and speedily integrate with a wide variety of databases.\n\nLibrary documentation: <a>http://numpy.org/</a>\n\n\n## The base `numpy.array` object\n\n::: {#setup .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\n# declare a vector using a list as the argument\nv = np.array([1, 2.0, 3, 4])\nv\n```\n:::\n\n\n::: {#94fb95e4 .cell execution_count=2}\n``` {.python .cell-code}\nlist([1, 2.0, 3, 4])\n```\n:::\n\n\n::: {#d5537527 .cell execution_count=3}\n``` {.python .cell-code}\ntype(v)\n```\n:::\n\n\n::: {#7cfd1b5f .cell execution_count=4}\n``` {.python .cell-code}\nv.shape\n```\n:::\n\n\n::: {#e1702d88 .cell execution_count=5}\n``` {.python .cell-code}\nv.ndim\n```\n:::\n\n\n::: {#822e08b2 .cell execution_count=6}\n``` {.python .cell-code}\nv.dtype is float\n```\n:::\n\n\n::: {#9df787e2 .cell execution_count=7}\n``` {.python .cell-code}\nv.dtype \n```\n:::\n\n\n::: {#d8f3702f .cell execution_count=8}\n``` {.python .cell-code}\nnp.uint8 is int\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"} \n\nUse copilot or any AI to *explain* to understand the chunks:\n\n>  The `np.uint8` is a data type in NumPy, representing an unsigned 8-bit integer, which can store values from 0 to 255. The `int` type is the built-in integer type in Python, which can represent any integer value without a fixed size limit.\n\n:::\n\n::: {#ab19ce51 .cell execution_count=9}\n``` {.python .cell-code}\ntry:\n    np.array([2**120, 2**40], dtype=np.int64)\nexcept OverflowError:\n    print('OverflowError: Python int too large to convert to C long')\n```\n:::\n\n\n::: {#4c554339 .cell execution_count=10}\n``` {.python .cell-code}\nnp.uint16 is int \n```\n:::\n\n\n::: {#75ec9d70 .cell execution_count=11}\n``` {.python .cell-code}\nnp.uint32  is int\n```\n:::\n\n\n::: {#a64bbfd0 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=12}\n``` {.python .cell-code}\nw = np.array([1.3, 2, 3, 4], dtype=np.int64)\nw\n```\n:::\n\n\n::: {#bf18ddfe .cell execution_count=13}\n``` {.python .cell-code}\nw.dtype\n```\n:::\n\n\n::: {#1193396d .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=14}\n``` {.python .cell-code}\na = np.arange(100)\n```\n:::\n\n\n::: {#d18dbbe1 .cell execution_count=15}\n``` {.python .cell-code}\ntype(a)\n```\n:::\n\n\n::: {#d05e019d .cell execution_count=16}\n``` {.python .cell-code}\nnp.array(range(100))\n```\n:::\n\n\n::: {#00af8d4b .cell execution_count=17}\n``` {.python .cell-code}\na\n```\n:::\n\n\n::: {#ddc50acf .cell execution_count=18}\n``` {.python .cell-code}\na.dtype\n```\n:::\n\n\n::: {#af648149 .cell execution_count=19}\n``` {.python .cell-code}\n-3 * a ** 2\n```\n:::\n\n\n::: {#51c51822 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=20}\n``` {.python .cell-code}\na[42] = 13\n```\n:::\n\n\n::: {#e46849a9 .cell execution_count=21}\n``` {.python .cell-code}\na[42] = 1025\n```\n:::\n\n\n::: {#f2b00c1f .cell execution_count=22}\n``` {.python .cell-code}\nnp.info(np.int16)\n```\n:::\n\n\n::: {#a1b6059a .cell execution_count=23}\n``` {.python .cell-code}\nnp.int16\n```\n:::\n\n\n::: {#22ba9085 .cell execution_count=24}\n``` {.python .cell-code}\ndict(enumerate(a))\n```\n:::\n\n\n::: {#68c4fb45 .cell execution_count=25}\n``` {.python .cell-code}\na + 1\n```\n:::\n\n\n::: {#3ea3c2bb .cell execution_count=26}\n``` {.python .cell-code}\nb = a + 1\nb\n```\n:::\n\n\n::: {#7a5b1188 .cell execution_count=27}\n``` {.python .cell-code}\na is b\n```\n:::\n\n\n::: {#43554d3b .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=28}\n``` {.python .cell-code}\nf = id(a)\na += 1\nf, id(a)\n```\n:::\n\n\n::: {#e2ff1dbc .cell execution_count=29}\n``` {.python .cell-code}\na\n```\n:::\n\n\n::: {#e32410a9 .cell execution_count=30}\n``` {.python .cell-code}\nb\n```\n:::\n\n\n::: {.callout-warning}\n\nBeware of the dimensions: a 1D array is not the same as a 2D array with 1 column\n\n::: \n\n::: {#443f6908 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=31}\n``` {.python .cell-code}\na1 = np.array([1, 2, 3])\nprint(a1, a1.shape, a1.ndim)\n```\n:::\n\n\n::: {#2d39da93 .cell execution_count=32}\n``` {.python .cell-code}\na2 = np.array([1, 2, 3])\nprint(a2, a2.shape, a2.ndim)\n```\n:::\n\n\n[More on NumPy quickstart](https://numpy.org/devdocs/user/quickstart.html)\n\n::: {.callout-note title=\"Question\" collapse=\"true\"}\n\nList the data attributes and methods (the attributes) of class `numpy.ndarray`. \nYou may use function `dir()` and filter the result using \nmethods for objects of class `string`. \n\n:::\n\n## Matrix multiplication\n\n::: {#0399137d .cell execution_count=33}\n``` {.python .cell-code}\na2.dot(a1) # inner product \n```\n:::\n\n\n::: {#3225a78f .cell execution_count=34}\n``` {.python .cell-code}\n( \n    np.array([a2])\n        .transpose() # column vector\n        .dot(np.array([a1]))\n) # column vector multiplied by row vector\n```\n:::\n\n\n::: {#0c8fdf12 .cell execution_count=35}\n``` {.python .cell-code}\n(\n    np.array([a2])\n    .transpose()#.shape\n)\n```\n:::\n\n\n::: {#7ab78860 .cell execution_count=36}\n``` {.python .cell-code}\n(\n    a2.reshape(3,1)  # all explicit\n      .dot(a1.reshape(1, 3))\n)\n```\n:::\n\n\n::: {#2478e753 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=37}\n``` {.python .cell-code}\n# Declare a 2D array using a nested list as the constructor argument\nM = np.array([[1,2], \n              [3,4], \n              [3.14, -9.17]])\nM\n```\n:::\n\n\n::: {#d4fa0d55 .cell execution_count=38}\n``` {.python .cell-code}\nM.shape, M.size\n```\n:::\n\n\n::: {#7f1d147d .cell execution_count=39}\n``` {.python .cell-code}\nM.ravel(), M.ndim, M.ravel().shape\n```\n:::\n\n\n::: {#24d3681a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=40}\n``` {.python .cell-code}\n# arguments: start, stop, step\nx = (\n     np.arange(12)\n       .reshape(4, 3)\n)\nx\n```\n:::\n\n\n::: {#9b6e25f9 .cell execution_count=41}\n``` {.python .cell-code}\ny = np.arange(3).reshape(3,1)\n\ny\n```\n:::\n\n\n::: {#8c15d4e4 .cell execution_count=42}\n``` {.python .cell-code}\nx @ y, x.dot(y)\n```\n:::\n\n\n::: {.callout-note}\n\n\n:::\n\n## Generating arrays\n\n::: {#a00edb0f .cell execution_count=43}\n``` {.python .cell-code}\nnp.linspace(0, 10, 51)  # meaning of the 3 positional parameters ? \n```\n:::\n\n\n::: {#026789f3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=44}\n``` {.python .cell-code}\nnp.logspace(0, 10, 11, base=np.e), np.e**(np.arange(11))\n```\n:::\n\n\n::: {#8b502632 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=45}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Random standard Gaussian numbers\nfig = plt.figure(figsize=(8, 4))\nwn = np.random.randn(1000)\nbm = wn.cumsum()\n\nplt.plot(bm, lw=3)\n```\n:::\n\n\n::: {#baa18c2b .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=46}\n``` {.python .cell-code}\nnp.diag(np.arange(10))\n```\n:::\n\n\n::: {#71a08ba4 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=47}\n``` {.python .cell-code}\nzozo = np.zeros((10, 10), dtype=np.float32)\nzozo\n```\n:::\n\n\n::: {#fbd86c08 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=48}\n``` {.python .cell-code}\nzozo.shape\n```\n:::\n\n\nCoercing to another `numpy` type\n\n::: {#b796dee4 .cell execution_count=49}\n``` {.python .cell-code}\nzozo.astype(np.short)[:5, :**5**]\n```\n:::\n\n\n::: {#aca08ebb .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=50}\n``` {.python .cell-code}\nprint(M)\n```\n:::\n\n\n::: {#510da93a .cell execution_count=51}\n``` {.python .cell-code}\nM[1, 1]\n```\n:::\n\n\n::: {#303cffe0 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=52}\n``` {.python .cell-code}\n# assign new value\nM[0, 0] = 7\nM[:, 0] = 42\nM\n```\n:::\n\n\n::: {#4005d5fc .cell execution_count=53}\n``` {.python .cell-code}\nM\n```\n:::\n\n\n::: {#802d45c4 .cell execution_count=54}\n``` {.python .cell-code}\n# Warning: the next m is a **view** on M. \n# One again, no copies unless you ask for one!\nm = M[0, :]\nm\n```\n:::\n\n\n::: {#4ee645f4 .cell execution_count=55}\n``` {.python .cell-code}\nm[:] = 3.14\nM\n```\n:::\n\n\n::: {#9ade81ba .cell execution_count=56}\n``` {.python .cell-code}\nm[:] = 7\nM\n```\n:::\n\n\n# Slicing\n\n::: {#ce286439 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=57}\n``` {.python .cell-code}\n# slicing works just like with anything else (lists, etc.)\nA = np.array([1, 2, 3, 4, 5])\nprint(A)\nprint(A[::-1])\nprint(A[::2])\nprint(A[:-1:2])\n```\n:::\n\n\n::: {#f9aaeecf .cell execution_count=58}\n``` {.python .cell-code}\n[[n + m * 10 for n in range(5)] for m in range(5)]\n```\n:::\n\n\n::: {#f2206b0f .cell execution_count=59}\n``` {.python .cell-code}\nA = np.array([[n + m * 10 for n in range(5)] for m in range(5)])\nA\n```\n:::\n\n\n::: {#b0374273 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=60}\n``` {.python .cell-code}\nprint(A[1:4])\n```\n:::\n\n\n::: {#017e841b .cell execution_count=61}\n``` {.python .cell-code}\nm = A[:, 1:4]\n```\n:::\n\n\n::: {#b263a87c .cell execution_count=62}\n``` {.python .cell-code}\nm[1, 1] = 123\n```\n:::\n\n\n::: {#e9b71596 .cell execution_count=63}\n``` {.python .cell-code}\nA\n```\n:::\n\n\n::: {#0895353b .cell execution_count=64}\n``` {.python .cell-code}\nA[1]\n```\n:::\n\n\n::: {#a98100c0 .cell execution_count=65}\n``` {.python .cell-code}\nA[:, 1]\n```\n:::\n\n\n::: {#978b3d39 .cell execution_count=66}\n``` {.python .cell-code}\nA[:, ::-1]\n```\n:::\n\n\n::: {#6ad71248 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=67}\n``` {.python .cell-code}\nprint(A)\n```\n:::\n\n\n::: {#a391df02 .cell execution_count=68}\n``` {.python .cell-code}\nrow_indices = np.array([1, 2, 4])\nprint(A[row_indices])\n```\n:::\n\n\n::: {#2602668f .cell execution_count=69}\n``` {.python .cell-code}\nA[:, row_indices]\n```\n:::\n\n\nAnother way is through masking with an array of `bool`s\n\n::: {#2b4eba50 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=70}\n``` {.python .cell-code}\n# index masking\nB = np.arange(5)\nrow_mask = np.array([True, False, True, False, False])\nprint(B)\nprint(B[row_mask])\n```\n:::\n\n\n::: {#dc2e4d48 .cell execution_count=71}\n``` {.python .cell-code}\nA, A[row_mask] , A[:,row_mask]\n```\n:::\n\n\n## Copies\n\nDon't forget that `python` *does not make copies unless told to do so* (same as with any mutable type)\n\nIf you are not careful enough, this typically leads to a *lot of errors* and to being fired !!\n\n::: {#dc64a3c1 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=72}\n``` {.python .cell-code}\ny = x = np.arange(6)\nx[2] = 123\ny\n```\n:::\n\n\n::: {#37fcf322 .cell execution_count=73}\n``` {.python .cell-code}\nx is y\n```\n:::\n\n\n::: {#c4caa6df .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=74}\n``` {.python .cell-code}\n# A real copy\ny = x.copy()\nx is y \n```\n:::\n\n\n::: {#d375fb16 .cell execution_count=75}\n``` {.python .cell-code}\n# Or equivalently (but the one above is better...)\ny = np.copy(x)\n```\n:::\n\n\n::: {#28635fed .cell execution_count=76}\n``` {.python .cell-code}\nx[0] = -12\nprint(x, y, x is y)\n```\n:::\n\n\nTo put values of x in y (copy values into an **existing** array) use  \n\n::: {#84a92ce7 .cell execution_count=77}\n``` {.python .cell-code}\nx = np.random.randn(10)\nx, id(x)\n```\n:::\n\n\n::: {#c92ccb22 .cell execution_count=78}\n``` {.python .cell-code}\nx.fill(2.78)   # in place. \nx, id(x)\n```\n:::\n\n\n::: {#af2fe037 .cell execution_count=79}\n``` {.python .cell-code}\nx[:] = 3.14  # x.fill(3.14)  can. be chained ...\nx, id(x)\n```\n:::\n\n\n::: {#e65e8f89 .cell execution_count=80}\n``` {.python .cell-code}\nx[:] = np.random.randn(x.shape[0])\nx, id(x)\n```\n:::\n\n\n::: {#8c266ef4 .cell execution_count=81}\n``` {.python .cell-code}\ny = np.empty(x.shape)  # how does empty() work ?\ny, id(y)\n```\n:::\n\n\n::: {#fdce3cf8 .cell execution_count=82}\n``` {.python .cell-code}\ny = x\ny, id(y), id(x), y is x\n```\n:::\n\n\n::: {.callout-warning}\n\n### Final warning\n\n:::\n\nIn the next line you copy the values of `x` into an existing array `y` (of same size...)\n\n::: {#68696a55 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=83}\n``` {.python .cell-code}\ny = np.zeros(x.shape)\ny[:] = x\ny, y is x, np.all(y==x)\n```\n:::\n\n\nWhile in the next line, you are aliasing, you are giving a new name `y` to the object named `x` (you should **never, ever** write something like this)\n\n::: {#9d7f0a74 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=84}\n``` {.python .cell-code}\ny = x\ny is x\n```\n:::\n\n\n## Miscellanea\n\n### Non-numerical values\n\nA `numpy` array can contain other things than numeric types\n\n::: {#e7781ae7 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=85}\n``` {.python .cell-code}\narr = np.array(['Labore', 'neque', 'ipsum', 'ut', 'non', 'quiquia', 'dolore.'])\narr, arr.shape, arr.dtype\n```\n:::\n\n\n::: {#32e0119f .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=86}\n``` {.python .cell-code}\n# arr.sum()\n```\n:::\n\n\n::: {#d42a2b8d .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=87}\n``` {.python .cell-code}\n\"_\".join(arr)\n```\n:::\n\n\n::: {#6a007fea .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"fragment\"}}' execution_count=88}\n``` {.python .cell-code}\narr.dtype\n```\n:::\n\n\n## A matrix is no 2D array in `numpy`\n\nSo far, we have only used `array` or `ndarray` objects\n\nThe is another type: the `matrix` type\n\nIn words: **don't use it** (IMhO) and stick with arrays\n\n::: {#969399b3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=89}\n``` {.python .cell-code}\n# Matrix VS array objects in numpy\nm1 = np.matrix(np.arange(3))\nm2 = np.matrix(np.arange(3))\nm1, m2\n```\n:::\n\n\n::: {#a9d9343e .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"fragment\"}}' execution_count=90}\n``` {.python .cell-code}\nm1.transpose() @ m2, m1.shape, m1.transpose() * m2\n```\n:::\n\n\n::: {#fc00d1d3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"fragment\"}}' execution_count=91}\n``` {.python .cell-code}\na1 = np.arange(3)\na2 = np.arange(3)\na1, a2\n```\n:::\n\n\n::: {#6cb56e1b .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=92}\n``` {.python .cell-code}\nm1 * m2.T, m1.dot(m2.T)\n```\n:::\n\n\n::: {#297a5634 .cell execution_count=93}\n``` {.python .cell-code}\na1 * a2\n```\n:::\n\n\n::: {#73013e35 .cell execution_count=94}\n``` {.python .cell-code}\na1.dot(a2)\n```\n:::\n\n\n::: {#e468f6a1 .cell execution_count=95}\n``` {.python .cell-code}\nnp.outer(a1, a2)\n```\n:::\n\n\n::: {.callout-note}\n\nVisit <https://numpy.org/doc/stable/reference/arrays.ndarray.html#arrays-ndarray>\n\n:::\n\n## Sparse matrices\n\n::: {#014d2330 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=96}\n``` {.python .cell-code}\nfrom scipy.sparse import csc_matrix, csr_matrix, coo_matrix\n```\n:::\n\n\n::: {#2b98dcf1 .cell execution_count=97}\n``` {.python .cell-code}\nprobs = np.full(fill_value=1/4, shape=(4,))\nprobs\n```\n:::\n\n\n::: {#3e5fff45 .cell execution_count=98}\n``` {.python .cell-code}\nX = np.random.multinomial(n=2, pvals=probs, size=4)   # check you understand what is going on \nX\n```\n:::\n\n\n::: {#90ce3ac3 .cell execution_count=99}\n``` {.python .cell-code}\nprobs\n```\n:::\n\n\n::: {#5da3a051 .cell execution_count=100}\n``` {.python .cell-code}\nX_coo = coo_matrix(X)  ## coordinate format\n```\n:::\n\n\n::: {#a101ac7a .cell execution_count=101}\n``` {.python .cell-code}\nprint(X_coo)\nX_coo\n```\n:::\n\n\n::: {#8fe54183 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=102}\n``` {.python .cell-code}\nX_coo.nnz    # number pf non-zero coordinates \n```\n:::\n\n\n::: {#e3332e92 .cell execution_count=103}\n``` {.python .cell-code}\nprint(X, end='\\n----\\n')\nprint(X_coo.data, end='\\n----\\n')\nprint(X_coo.row, end='\\n----\\n')\nprint(X_coo.col, end='\\n----\\n')\n```\n:::\n\n\nThere is also\n\n- `csr_matrix`: sparse rows format \n- `csc_matrix`: sparse columns format\n\nSparse rows is often used for machine learning: sparse features vectors\n\nBut sparse column format useful as well (e.g. coordinate gradient descent)\n\n## Bored with decimals?\n\n::: {#dafd8e0a .cell execution_count=104}\n``` {.python .cell-code}\nX = np.random.randn(5, 5)\nX\n```\n:::\n\n\n::: {#ed675f70 .cell execution_count=105}\n``` {.python .cell-code}\n# All number displayed by numpy (in the current kernel) are with 3 decimals max\nnp.set_printoptions(precision=3)\nprint(X)\nnp.set_printoptions(precision=8)\n```\n:::\n\n\n## Not limited to 2D!\n\n`numpy` arrays can have any number of dimension (hence the name `ndarray`)\n\n::: {#d729deda .cell execution_count=106}\n``` {.python .cell-code}\nX = np.arange(18).reshape(3, 2, 3)\nX\n```\n:::\n\n\n::: {#2b00b28e .cell execution_count=107}\n``` {.python .cell-code}\nX.shape\n```\n:::\n\n\n::: {#e0456f2b .cell execution_count=108}\n``` {.python .cell-code}\nX.ndim\n```\n:::\n\n\nVisit <https://numpy.org/doc/stable/reference/arrays.ndarray.html#arrays-ndarray>\n\n# Aggregations and statistics\n\n::: {#ce3ba4b7 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=109}\n``` {.python .cell-code}\nA = np.arange(42).reshape(7, 6)\nA\n```\n:::\n\n\n::: {#207432c5 .cell execution_count=110}\n``` {.python .cell-code}\nA.sum(), 42 * 41 //2\n```\n:::\n\n\n::: {#078f18c4 .cell execution_count=111}\n``` {.python .cell-code}\nA[:, 3].mean(), np.mean (3 + np.arange(0, 42, 6))\n```\n:::\n\n\n::: {#48dfaad3 .cell execution_count=112}\n``` {.python .cell-code}\nA.mean(axis=0)\n```\n:::\n\n\n::: {#0f6fb3c6 .cell execution_count=113}\n``` {.python .cell-code}\nA.mean(axis=1)\n```\n:::\n\n\n::: {#ab834d32 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=114}\n``` {.python .cell-code}\nA[:,3].std(), A[:,3].var()\n```\n:::\n\n\n::: {#39b0ef3b .cell execution_count=115}\n``` {.python .cell-code}\nA[:,3].min(), A[:,3].max()\n```\n:::\n\n\n::: {#e89142aa .cell execution_count=116}\n``` {.python .cell-code}\nA.cumsum(axis=0)\n```\n:::\n\n\n::: {#e1e82b7d .cell execution_count=117}\n``` {.python .cell-code}\nA\n```\n:::\n\n\n::: {#f2ed8251 .cell execution_count=118}\n``` {.python .cell-code}\n# sum of diagonal\nA.trace()\n```\n:::\n\n\n# Linear Algebra\n\n::: {#ab03bbc5 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=119}\n``` {.python .cell-code}\nA = np.arange(30).reshape(6, 5)\nv1 = np.arange(0, 5)\nv2 = np.arange(5, 10)\n```\n:::\n\n\n::: {#b7f5e5a8 .cell execution_count=120}\n``` {.python .cell-code}\nA\n```\n:::\n\n\n::: {#67d7ad78 .cell execution_count=121}\n``` {.python .cell-code}\nv1, v2\n```\n:::\n\n\n::: {#d1fcaaa2 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=122}\n``` {.python .cell-code}\nv1 * v2\n```\n:::\n\n\n::: {#60770e72 .cell execution_count=123}\n``` {.python .cell-code}\nv1.dot(v2), np.sum(v1* v2)\n```\n:::\n\n\n::: {#b1c931d7 .cell execution_count=124}\n``` {.python .cell-code}\nv1.reshape(5,1) @ v2.reshape(1,5)\n```\n:::\n\n\n## Inner products\n\n::: {#a76b0e40 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=125}\n``` {.python .cell-code}\n# Inner product between vectors\nprint(v1.dot(v2))\n\n# You can use also (but first solution is better)\nprint(np.dot(v1, v2))\n```\n:::\n\n\n::: {#85fef18a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=126}\n``` {.python .cell-code}\nA, v1\n```\n:::\n\n\n::: {#922577ce .cell execution_count=127}\n``` {.python .cell-code}\nA.shape, v1.shape\n```\n:::\n\n\n::: {#736636a3 .cell execution_count=128}\n``` {.python .cell-code}\n# Matrix-vector inner product\nA.dot(v1)\n```\n:::\n\n\n::: {#b112a655 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=129}\n``` {.python .cell-code}\n# Transpose\nA.T\n```\n:::\n\n\n::: {#b70c7aa4 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=130}\n``` {.python .cell-code}\nprint(v1)\n# Inline operations (same for *=, /=, -=)\nv1 += 2\n```\n:::\n\n\n## Linear systems\n\n::: {#7c0899d1 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=131}\n``` {.python .cell-code}\nA = np.array([[42,2,3], [4,5,6], [7,8,9]])\nb = np.array([1,2,3])\nprint(A, b, sep=2 * '\\n')\n```\n:::\n\n\n::: {#bfe2087a .cell execution_count=132}\n``` {.python .cell-code}\n# solve a system of linear equations\nx = np.linalg.solve(A, b)\nx\n```\n:::\n\n\n::: {#a3a58c4b .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=133}\n``` {.python .cell-code}\nA.dot(x)\n```\n:::\n\n\n## Eigenvalues and eigenvectors\n\n::: {#a9799768 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"-\"}}' execution_count=134}\n``` {.python .cell-code}\nA = np.random.rand(3,3)\nB = np.random.rand(3,3)\n\nevals, evecs = np.linalg.eig(A)\nevals\n```\n:::\n\n\n::: {#151a5a00 .cell execution_count=135}\n``` {.python .cell-code}\nevecs\n```\n:::\n\n\n## Singular value decomposition (SVD)\n\nDecomposes any matrix $A \\in \\mathbb R^{m \\times n}$ as follows:\n$$\nA = U \\times S \\times V^\\top\n$$\nwhere \n- $U$ and $V$ are orthonormal matrices (meaning that $U^\\top \\times U = I$ and $V^\\top \\times V = I$)\n- $S$ is a diagonal matrix that contains the *singular* values in non-increasing order\n\n::: {#89b29d7e .cell execution_count=136}\n``` {.python .cell-code}\nprint(A)\nU, S, V = np.linalg.svd(A)\n```\n:::\n\n\n::: {#5c7f63ac .cell execution_count=137}\n``` {.python .cell-code}\nU.dot(np.diag(S)).dot(V)\n```\n:::\n\n\n::: {#2d87d705 .cell execution_count=138}\n``` {.python .cell-code}\nA - U @ np.diag(S) @ V\n```\n:::\n\n\n::: {#07f18ca8 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=139}\n``` {.python .cell-code}\n# U and V are indeed orthonormal\nnp.set_printoptions(precision=2)\nprint(U.T.dot(U), V.T.dot(V), sep=2 * '\\n')\nnp.set_printoptions(precision=8)\n```\n:::\n\n\n## Exercice: the racoon SVD\n\n- Load the racoon face picture using `scipy.misc.face()`\n- Visualize the picture\n- Write a function which reshapes the picture into a 2D array, and computes the best rank-r approximation of it (the prototype of the function is `compute_approx(X, r)`\n- Display the different approximations for r between 5 and 100\n\n::: {#cfeafa9c .cell execution_count=140}\n``` {.python .cell-code}\n!pip3 install pooch\n```\n:::\n\n\n::: {#8de741f0 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=141}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.datasets import face\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nX = face()\n```\n:::\n\n\n::: {#5256b781 .cell execution_count=142}\n``` {.python .cell-code}\ntype(X)\n```\n:::\n\n\n::: {#cc788064 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=143}\n``` {.python .cell-code}\nplt.imshow(X)\n_ = plt.axis('off')\n```\n:::\n\n\n::: {#94139adc .cell execution_count=144}\n``` {.python .cell-code}\nn_rows, n_cols, n_channels = X.shape\nX_reshaped = X.reshape(n_rows, n_cols * n_channels)\nU, S, V = np.linalg.svd(X_reshaped, full_matrices=False)\n```\n:::\n\n\n::: {#92b3f17e .cell execution_count=145}\n``` {.python .cell-code}\nX_reshaped.shape\n```\n:::\n\n\n::: {#4df299db .cell execution_count=146}\n``` {.python .cell-code}\nX.shape\n```\n:::\n\n\n::: {#7066dec0 .cell execution_count=147}\n``` {.python .cell-code}\nplt.plot(S**2)  ## a kind of screeplot\nplt.yscale(\"log\")\n```\n:::\n\n\n::: {#6f83fcb9 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=148}\n``` {.python .cell-code}\ndef compute_approx(X: np.ndarray, r: int):\n    \"\"\"Computes the best rank-r approximation of X using SVD.\n    We expect X to be the 3D array corresponding to a color image, that we \n    reduce to a 2D one to apply SVD (no broadcasting).\n    \n    Parameters\n    ----------\n    X : `np.ndarray`, shape=(n_rows, n_cols, 3)\n        The input 3D ndarray\n    \n    r : `int`\n        The desired rank\n        \n    Return\n    ------\n    output : `np.ndarray`, shape=(n_rows, n_cols, 3)\n        The best rank-r approximation of X\n    \"\"\"\n    n_rows, n_cols, n_channels = X.shape\n    # Reshape X to a 2D array\n    X_reshape = X.reshape(n_rows, n_cols * n_channels)\n    # Compute SVD\n    U, S, V = np.linalg.svd(X_reshape, full_matrices=False)\n    # Keep only the top r first singular values\n    S[r:] = 0\n    # Compute the approximation\n    X_reshape_r = U.dot(np.diag(S)).dot(V)\n    # Put it between 0 and 255 again and cast to integer type\n    return (\n        X_reshape_r\n            .clip(min=0, max=255)\n            .astype('int')\n            .reshape(n_rows, n_cols, n_channels)\n    )\n```\n:::\n\n\n::: {#9f04cdd6 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=149}\n``` {.python .cell-code}\nranks = [100, 70, 50, 30, 10, 5]\nn_ranks = len(ranks)\nfor i, r in enumerate(ranks):\n    X_r = compute_approx(X, r)\n    # plt.subplot(n_ranks, 1, i + 1)\n    plt.figure(figsize=(5, 5))\n    plt.imshow(X_r)\n    _ = plt.axis('off')\n    # plt.title(f'Rank {r} approximation of the racoon' % r, fontsize=16)\n    plt.tight_layout()\n```\n:::\n\n\n::: {.callout-tip appearance=\"simple\"}\n\n### Variations\n\nIn the code above, we recompute the SVD of `X` for every element in list `rank`.    \nIn the next chunk, we compute the SVD once, and define a *generator* to generate the low rank approximations of matrix `X`. We take advantage of the fact that the SVD defines an orthonormal basis for the space of matrices. In this adapted orthonormal basis the optimal  low rank approximations of $X$ have  a sparse expansion.\n\n:::\n\n::: {#4359f7e1 .cell execution_count=150}\n``` {.python .cell-code}\ndef gen_rank_k_approx(X):\n    \"\"\"Generator for low rank \n    approximation of a matrix X using truncated SVD.\n\n    Args:\n        X (numpy.ndarray): a numerical matrix\n\n    Yields:\n        (int,numpy.ndarray): rank k and best rank-k approximation of X using truncated SVD(according to Eckart-Young theorem).\n    \"\"\"  \n    U, S, V = np.linalg.svd(X, full_matrices=False)\n    r = 0\n    Y = np.zeros_like(X, dtype='float64')\n    while (r<len(S)):\n      Y = Y + S[r] * (U[:, r, np.newaxis] @ V[r, :, np.newaxis].T)\n      r += 1\n      yield r, Y\n```\n:::\n\n\n::: {#0fc44131 .cell execution_count=151}\n``` {.python .cell-code}\ng = gen_rank_k_approx(X_reshaped) \n```\n:::\n\n\n::: {#f633be7b .cell execution_count=152}\n``` {.python .cell-code}\nfor i in range(100):\n    _, Xr = next(g)\n    if i % 10 ==0:  \n      plt.figure(figsize=(5, 5))\n      plt.imshow(\n          Xr\n          .clip(min=0, max=255)\n          .astype('int')\n          .reshape(n_rows, n_cols, n_channels)\n      )\n      _ = plt.axis('off')\n      plt.tight_layout()\n```\n:::\n\n\nVisit <https://numpy.org/numpy-tutorials/content/tutorial-svd.html>\n\n\n# Broadcasting\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /usr/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.12.3\n---\n",
    "supporting": [
      "notebook02_numpy_files"
    ],
    "filters": []
  }
}