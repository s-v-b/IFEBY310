---
title: Introduction to Python
jupyter: python3

engine: jupyter
---


We introduce here the `python` language. 

Only the bare necessities  for getting started with the data science stack (a bunch of libraries for data science).
Python is a **programming language**, as are `C++`, `java`, `fortran`, `javascript`,
etc.


## Specific features of Python

- an **interpreted** (as opposed to *compiled*) language. Contrary to e.g.
`C++` or `fortran`, one does not compile Python code before executing it. 

- Used as a scripting language, by python `python script.py` in a terminal

- But can be used also **interactively**: the jupyter notebook, iPython, etc.

- A free software released under an **open-source** license: Python can
be used and distributed free of charge, even for building commercial
software.

- **multi-platform**: Python is available for all major operating
systems, Windows, Linux/Unix, MacOS X, most likely your mobile phone
OS, etc.

- A very readable language with clear non-verbose syntax

- A language for which a **large amount of high-quality** packages are
available for various applications, including web-frameworks and scientific
computing

- It has been one of the top **languages for data science** and **machine learning** for  years, because it is  expressive and and easy to deploy

- An object-oriented language

See https://www.python.org/about/ for more information about distinguishing features of Python.

::: {.content-hidden unless-profile="confidential"}

### Python 2 or Python 3?

- Simple answer: *don't use Python 2, use Python 3*
- Python 2 is *mostly deprecated* and *has not been maintained* for years 
- You'll end up hanged if you use Python 2
- If Python 2 is mandatory at your workplace, find another work

:::

::: {.callout-important}

### Jupyter or Quarto notebooks?

- `quarto` is more `git` friendly than `jupyter`
- Enjoy authentic editors
  
- Go for `quarto`
  
:::

# Hello world

- In a `jupyter`/`quarto` notebook, you have an interactive interpreter.

- You type in the cells, execute commands 

```{python}
#| slideshow: {slide_type: fragment}
print("Hi everybody!")
```

# Basic types

## Integers

```{python}
#| slideshow: {slide_type: fragment}
1 + 42
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
type(1+1)
```

We can *assign* values to variables with `=`

```{python}
#| slideshow: {slide_type: '-'}
a = (3 + 5 ** 2) % 4
a
```

## Remark

We are not compelled declare the type of a variable before assigning its value. 
In C, conversely, one should write

```C
int a = 4;
```

::: {.callout-note}

Since Python 3.5, it is possible but not mandatory to provide type hints in function signatures. 

:::


## Something cool

- **Arbitrary large** integer arithmetics

```{python}
#| slideshow: {slide_type: fragment}
17 ** 542
```

## Floats

There exists a floating point type that is created when the variable has decimal values

```{python}
#| slideshow: {slide_type: '-'}
c = 2.
```

```{python}
#| slideshow: {slide_type: '-'}
type(c)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
c = 2
type(c)
```

```{python}
#| slideshow: {slide_type: fragment}
truc = 1 / 2
truc
```

```{python}
1 // 2 + 1 % 2
```

```{python}
#| slideshow: {slide_type: '-'}
type(truc)
```

## Boolean

Similarly, boolean types are created from a comparison

```{python}
#| slideshow: {slide_type: fragment}
test = 3 > 4
test
```

```{python}
#| slideshow: {slide_type: '-'}
type(test)
```

```{python}
#| slideshow: {slide_type: fragment}
False == (not True)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
1.41 < 2.71 and 2.71 < 3.14
```

```{python}
#| slideshow: {slide_type: '-'}
# It's equivalent to
1.41 < 2.71 < 3.14
```

## Type conversion (casting)

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
a = 1
type(a)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
b = float(a)
type(b)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
str(b)
```

```{python}
#| slideshow: {slide_type: fragment}
bool(b)
# All non-zero, non empty objects are casted to boolean as True (more later)
```

```{python}
#| slideshow: {slide_type: '-'}
bool(1-1)
```

#  Containers

Python provides many efficient types of *containers* or *sequences*, in which collections of objects can be stored. 

The main ones are `list`, `tuple`, `set` and `dict` (but there are many others...)

## Tuples

```{python}
#| slideshow: {slide_type: fragment}
tt = 'truc', 3.14, "truc"
tt
```

```{python}
#| slideshow: {slide_type: '-'}
tt[0]
```

You can't change a tuple, we say that it's *immutable*

```{python}
#| 
#| slideshow: {slide_type: '-'}
try:
    tt[0] = 1
except TypeError:
    print(f"TypeError: 'tuple' object does not support item assignment")
```

Three ways of doing the same thing

```{python}
#| slideshow: {slide_type: '-'}
# Method 1
tuple([1, 2, 3])
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
# Method 2
1, 2, 3
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
# Method 3
toto = (1, 2, 3)
toto = tuple([1,2,3])
```

**Simpler is better in Python**, so usually you want to use Method 2.

```{python}
#| slideshow: {slide_type: fragment}
toto = 1, 2, 3
toto
```

- This is serious !

## The Zen of Python easter's egg

```{python}
#| slideshow: {slide_type: '-'}
import this
```

## Lists

A list is an ordered collection of objects. These objects may have different types. For example:

```{python}
#| slideshow: {slide_type: '-'}
colors = ['red', 'blue', 'green', 'black', 'white']
```

```{python}
colors[0]
```

```{python}
#| slideshow: {slide_type: '-'}
type(colors)
```

*Indexing:* accessing individual objects contained in the list by their position

```{python}
#| slideshow: {slide_type: '-'}
colors[2]
```

```{python}
#| slideshow: {slide_type: '-'}
colors[2] = 3.14
colors
```

::: {.callout-warning}

For any *iterable* object in Python, indexing *starts at 0* (as in C), not at 1 (as in Fortran, R, or Matlab).

:::

Counting from the end with negative indices:

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
colors[-1]
```

Index must remain in the range of the list

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
#| eval: false
try:
    colors[10]
except IndexError:
    print(f"IndexError: 10 >= {len(colors)} ==len(colors), index out of range ")
```

```{python}
#| slideshow: {slide_type: subslide}
colors
```

```{python}
tt
```

```{python}
#| slideshow: {slide_type: '-'}
colors.append(tt)
colors
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
len(colors)
```

```{python}
len(tt)
```

## Slicing: obtaining sublists of regularly-spaced elements

This work with anything iterable whenever it makes sense (`list`, `str`, `tuple`, etc.)

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
colors
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
list(reversed(colors))
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
colors[::-1]
```

::: {.callout-important}

### Slicing syntax: 

`colors[start:stop:stride]`

`start, stop, stride` are optional, with default values `0, len(sequence), 1`

:::
l

```{python}
print(slice(4))
print(slice(1,5))
print(slice(None,13,3))
```

```{python}
sl = slice(1,5,2)
colors[sl]
```


```{python}
#| slideshow: {slide_type: subslide}
colors
```

```{python}
#| slideshow: {slide_type: '-'}
colors[3:]
```

```{python}
#| slideshow: {slide_type: '-'}
colors[:3]
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
colors[1::2]
```

```{python}
#| slideshow: {slide_type: '-'}
colors[::-1]
```

## Strings

Different string syntaxes (simple, double or triple quotes):

```{python}
#| slideshow: {slide_type: fragment}
s = 'tintin'
type(s)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
s
```

```{python}
#| slideshow: {slide_type: fragment}
s = """         Bonjour,
Je m'appelle Stephane.
Je vous souhaite une bonne journée.
Salut.       
"""
s
```

```{python}
#| slideshow: {slide_type: '-'}
s.strip()
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
print(s.strip())
```

```{python}
#| slideshow: {slide_type: '-'}
len(s)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
# Casting to a list
list(s.strip()[:15])
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
# Arithmetics
print('Bonjour' * 2)
print('Hello' + ' all')
```

```{python}
#| slideshow: {slide_type: '-'}
sss = 'A'
sss += 'bc'
sss += 'dE'
sss.lower()
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
ss = s.strip()
print(ss[:10] + ss[24:28])
```

```{python}
s.strip()
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
s.strip().split('\n')
```

```{python}
#| slideshow: {slide_type: '-'}
s[::3]
```

```{python}
#| slideshow: {slide_type: '-'}
s[3:10]
```

```{python}
#| slideshow: {slide_type: fragment}
" ".join(['Il', 'fait', 'super', 'beau', "aujourd'hui"])
```

Chaining method calls is the basic of pipeline building. 

```{python}
( 
    " ".join(['Il', 'fait', 'super', 'beau', "aujourd'hui"])
       .title()
       .replace(' ', '')
       .replace("'","")
)
```

### Important

A string is *immutable* !!

```{python}
#| slideshow: {slide_type: '-'}
#|
s = 'I am an immutable guy'
```

```{python}
#| slideshow: {slide_type: '-'}

try:  
    s[2] = 's'
except TypeError:
    print(f"Strings are immutable! s is still '{s}'")
```

```{python}
#| slideshow: {slide_type: fragment}
id(s)
```

```{python}
#| scrolled: true
print(s + ', for sure')
id(s), id(s + ' for sure')
```

### Extra stuff with strings

```{python}
#| slideshow: {slide_type: '-'}
'square of 2 is ' + str(2 ** 2)
```

```{python}
#| slideshow: {slide_type: '-'}
'square of 2 is %d' % 2 ** 2
```

```{python}
#| slideshow: {slide_type: '-'}
'square of 2 is {}'.format(2 ** 2)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
'square of 2 is {square}'.format(square=2 ** 2)
```

```{python}
#| slideshow: {slide_type: fragment}
# And since Python 3.6 you can use an `f-string`
number = 2
square = number ** 2

f'square of {number} is {square}'
```



### The `in` keyword

You can use the `in` keyword with any container, whenever it makes sense

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
print(s)
print('Salut' in s)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
print(tt)
print('truc' in tt)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
print(colors)
print('truc' in colors)
```

```{python}
#| scrolled: true
('truc', 3.14, 'truc') in colors
```

::: {.callout-warning}

Strings are not bytes. Have a look at chapter 4 *Unicode Text versus Bytes* in [Fluent Python](https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/) 

:::

### Brain-teasing

Explain this weird behaviour:

```{python}
5 in [1, 2, 3, 4] == False
```

```{python}
#| slideshow: {slide_type: '-'}
[1, 2, 3, 4] == False
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
5 not in [1, 2, 3, 4]
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
(5 in [1, 2, 3, 4]) == False
```

```{python}
#| slideshow: {slide_type: fragment}
# ANSWER.
# This is a chained comparison. We have seen that 
1 < 2 < 3
# is equivalent to
(1 < 2) and (2 < 3)
# so that
5 in [1, 2, 3, 4] == False
# is equivalent to
(5 in [1, 2, 3, 4]) and ([1, 2, 3, 4] == False)
```

```{python}
(5 in [1, 2, 3, 4])
```

```{python}
([1, 2, 3, 4] == False)
```

## Dictionaries

- A dictionary is basically an efficient table that **maps keys to values**.
- The **MOST** important container in Python. 
- Many things are actually a `dict` under the hood in `Python`

```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
tel = {'emmanuelle': 5752, 'sebastian': 5578}
print(tel)
print(type(tel))
```

```{python}
#| slideshow: {slide_type: fragment}
tel['emmanuelle'], tel['sebastian']
```

```{python}
tel['francis'] = '5919'
tel
```

```{python}
#| scrolled: true
len(tel)
```

### Important remarks

- Keys can be of different types
- A key must be of **immutable** type

```{python}
#| scrolled: true
tel[7162453] = [1, 3, 2]
tel[3.14] = 'bidule'
tel[('jaouad', 2)] = 1234
tel
```

```{python}
try:
    sorted(tel)
except TypeError:
    print("TypeError: '<' not supported between instances of 'int' and 'str'")    
```

```{python}
# A list is mutable and not hashable
try:
    tel[['jaouad']] = '5678'
except TypeError:
    print("TypeError: unhashable type: 'list'")
```

```{python}
try:
    tel[2]
except KeyError:
    print("KeyError: 2")
```

```{python}
#| slideshow: {slide_type: subslide}
tel = {'emmanuelle': 5752, 'sebastian' : 5578, 'jaouad' : 1234}
print(tel.keys())
print(tel.values())
print(tel.items())
```

```{python}
list(tel.keys())[2]
```

```{python}
tel.values().mapping
```

```{python}
type(tel.keys())
```

```{python}
#| slideshow: {slide_type: fragment}
'rémi' in tel
```

```{python}
list(tel)
```

```{python}
'rémi' in tel.keys()
```

You can swap values like this

```{python}
#| scrolled: true
print(tel)
tel['emmanuelle'], tel['sebastian'] = tel['sebastian'], tel['emmanuelle']
print(tel)
```

```{python}
#| scrolled: true
# It works, since
a, b = 2.71, 3.14
a, b = b, a
a, b
```

### Exercise 1

Get keys of `tel` sorted by decreasing order

```{python}
#| slideshow: {slide_type: '-'}
tel = {'emmanuelle': 5752, 'sebastian' : 5578, 'jaouad' : 1234}
```
::: {.content-visible when-profile='solution'} 
 
#### Answer

```{python}
#| scrolled: true
sorted(tel, reverse=True)
```

```{python}
type(sorted(tel, reverse=True))
```

:::

### Exercise 2

Get keys of `tel` sorted by increasing _values_

```{python}
tel = {'emmanuelle': 5752, 'sebastian' : 5578, 'jaouad' : 1234}
```

::: {.content-visible when-profile='solution'} 
 
#### Answer

```{python}
tel["sebastian"]
```

```{python}
tel.get('rémi')
```

```{python}
#| slideshow: {slide_type: '-'}
sorted(tel, key=tel.get)
```

:::

### Exercise 3

Obtain a sorted-by-key version of `tel`

```{python}
tel = {'emmanuelle': 5752, 'sebastian' : 5578, 'jaouad' : 1234}
```

::: {.content-visible when-profile='solution'} 
 
#### Answer

- A dict is inherently **orderless**
- Only a _representation_ of a dict can be ordered

```{python}
#| slideshow: {slide_type: fragment}
# Simplest is through a list
print(type(tel.items()))
issubclass(type(tel.items()), list)
```

```{python}
sorted(tel.items())
```

If you really want an ordered dict `OrderDict` memorizes order of insertion in it

```{python}
from collections import OrderedDict

OrderedDict(sorted(tel.items()))
```

:::

## Sets

A set is an unordered container, containing unique elements

```{python}
#| scrolled: true
ss = {1, 2, 2, 2, 3, 3, 'tintin', 'tintin', 'toto'}
ss
```

```{python}
s = 'truc truc bidule truc'
set(s)
```

```{python}
set(list(s))
```

```{python}
#| slideshow: {slide_type: fragment}
{1, 5, 2, 1, 1}.union({1, 2, 3})
```

```{python}
set((1, 5, 3, 2))
```

```{python}
set([1, 5, 2, 1, 1]).intersection(set([1, 2, 3]))
```

```{python}
ss.add('tintin')
ss
```

```{python}
ss.difference(range(6))
```

You can combine all containers together

```{python}
#| scrolled: true
dd = {
    'truc': [1, 2, 3], 
    5: (1, 4, 2),
    (1, 3): {'hello', 'world'}
}
dd
```

# Assigments in `Python` is name binding

## Everything is either mutable or immutable

```{python}
#| slideshow: {slide_type: subslide}
ss = {1, 2, 3}
sss = ss
sss, ss
```

```{python}
id(ss), id(sss)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
sss.add("Truc")
```

**Question.** What is in `ss` ?

```{python}
#| slideshow: {slide_type: fragment}
ss, sss
```

`ss` and `sss` are names for the same object

```{python}
#| slideshow: {slide_type: '-'}
id(ss), id(sss)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
ss is sss
```

```{python}
help('is')
```

## About assigments

- Python never copies an object
- Unless you ask him to

When you code
```python
x = [1, 2, 3]
y = x
```
you just
- **bind** the variable name `x` to a list `[1, 2, 3]`
- give another name `y` to the same object

**Important remarks**

- **Everything** is an object in Python
- Either **immutable** or **mutable**

```{python}
#| scrolled: true
id(1), id(1+1), id(2)
```

*A `list` is mutable*

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
x = [1, 2, 3]
print(id(x), x)
x[0] += 42; x.append(3.14)
print(id(x), x)
```

*A `str` is immutable*

In order to *change* an **immutable** object, Python creates a new one

```{python}
s = 'to'
print(id(s), s)
s += 'to'
print(id(s), s)
```

*Once again, a `list` is mutable*

```{python}
#| slideshow: {slide_type: '-'}
super_list = [3.14, (1, 2, 3), 'tintin']
other_list = super_list
id(other_list), id(super_list)
```

- `other_list` and `super_list` denote the same list. `other_list` is an *alias* for `super_list`
- If you change one, you change the other.
- `id` returns the identity of an object. Two objects with the same idendity are the same (not only the same type, but the same instance)

```{python}
other_list[1] = 'youps'
other_list, super_list
```

```{python}
id(super_list), id(other_list)
```

## If you want a copy, to need to ask for one

```{python}
other_list = super_list.copy()
id(other_list), id(super_list)
```

```{python}
other_list[1] = 'copy'
other_list, super_list
```

Only `other_list` is modified. 

But... what if you have a `list` of `list` ? (or a mutable object containing mutable objects)

```{python}
#| slideshow: {slide_type: fragment}
l1, l2 = [1, 2, 3], [4, 5, 6]
list_list = [l1, l2]
list_list
```

```{python}
id(list_list), id(list_list[0]), id(l1), list_list[0] is l1
```

Let's make a copy of `list_list`

```{python}
copy_list = list_list.copy()
copy_list.append('super')
list_list, copy_list
```

```{python}
id(list_list[0]), id(copy_list[0])
```

OK, only `copy_list` is modified, as expected

But now...

```{python}
copy_list[0][1] = 'oups'
copy_list, list_list
```

**Question.** What happened ?!?

- The `list_list` object is copied
- But NOT what it's containing !
- By default `copy` does a *shallow* copy, not a *deep* copy
- It does not build copies of what is contained
- If you want to copy an object and all that is contained in it, you need to use `deepcopy`.

```{python}
from copy import deepcopy

copy_list = deepcopy(list_list)
copy_list[0][1] = 'incredible !'
list_list, copy_list
```

## Final remarks

```{python}
tt = ([1, 2, 3], [4, 5, 6])
print(id(tt), tt)
print(list(map(id, tt)))
```

```{python}
#| scrolled: true
tt[0][1] = '42'
print(id(tt), tt)
print(list(map(id, tt)))
```

```{python}
s = [1, 2, 3]
```

```{python}
s2 = s
```

```{python}
s2 is s
```

```{python}
id(s2), id(s)
```

# Control flow and other stuff...

Namely tests, loops, again booleans, etc.

```{python}
#| slideshow: {slide_type: subslide}
if 2 ** 2 == 5:
    print('Obvious')
else:
    print('YES')
print('toujours')
```

## Blocks are delimited by indentation!

```{python}
a = 3
if a > 0:
    if a == 1:
        print(1)
    elif a == 2:
        print(2)
elif a == 2:
    print(2)
elif a == 3:
    print(3)
else:
    print(a)
```

## Anything can be understood as a boolean

For example, don't do this to test if a list is empty

```{python}
l2 = ['hello', 'everybody']

if len(l2) > 0:
    print(l2[0])
```

but this

```{python}
#| scrolled: true
if l2:
    print(l2[0])
```

**Some poetry**

- An empty `dict` is `False`
- An empty `string` is `False`
- An empty `list` is `False`
- An empty `tuple` is `False`
- An empty `set` is `False`
- `0` is `False`
- `.0` is `False`
- etc...
- everything else is `True`

```{python}
# %%
[bool(x) for x in ['', False, 0, [], {}, set(), dict(), {'': 0}]]
```

## While loops

```{python}
a = 10
b = 1
while b < a:
    b = b + 1
    print(b)
```

Compute the decimals of Pi using the Wallis formulae

$$
\pi = 2 \lim_{n \to \infty} \prod_{i=1}^{n} \frac{4i^2}{4i^2 - 1}
$$

```{python}

from math import pi


pi_approx = 2
eps = 1e-10
dif = 2 * eps
i = 1
while dif > eps:
    pi_approx, i, old_pi = pi_approx * 4 * i ** 2 / (4 * i ** 2 - 1), i + 1, pi_approx
    dif = pi_approx - old_pi
else:
    print(f'After {i} iterations, the difference between the approximation and the target is  {pi_approx-pi}')
```




##  `for` loop with `range`

- Iteration with an index, with a list, with many things !
- `range` has the same parameters as with slicing `start:end:stride`, all parameters being optional

```{python}
#| scrolled: true
for i in range(10):
    print(i)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
for i in range(4):
    print(i + 1)
print('-')

for i in range(1, 5):
    print(i)
print('-')

for i in range(1, 10, 3):
    print(i)
```

*Something for nerds*. You can use `else` in a `for` loop

```{python}
names = ['gaston', 'mokhtar', 'jaouad', 'simon', 'yiyang']

for name in names:
    if name.startswith('u'):
        print(name)
        break
else:
    print('Not found.')
```

```{python}
#| scrolled: true
names = ['gaston', 'mokhtar', 'jaouad', 'ulysse', 'simon', 'yiyang']

for name in names:
    if name.startswith('u'):
        print(name)
        break
else:
    print('Not found.')
```

## For loops over iterable objects

You can iterate using `for` over any container: `list`, `tuple`, `dict`, `str`, `set` among others...

```{python}
colors = ['red', 'blue', 'black', 'white']
peoples = ['gaston', 'jaouad', 'mokhtar', 'yiyang', 'rémi']
```

```{python}
#| scrolled: true
# This is stupid
for i in range(len(colors)):
    print(colors[i])
    
# This is better
for color in colors:
    print(color)
```

To iterate over several sequences at the same time, use `zip`

```{python}
for color, people in zip(colors, peoples):
    print(color, people)
```

```{python}
#| slideshow: {slide_type: fragment}
l = ["Bonjour", {'francis': 5214, 'gaston': 5123}, ('truc', 3)]
for e in l:
    print(e, len(e))
```

**Loop over a `str`**

```{python}
#| scrolled: true
s = 'Bonjour'
for c in s:
    print(c)
```

**Loop over a `dict`**


```{python}
dd = {(1, 3): {'hello', 'world'}, 'truc': [1, 2, 3], 5: (1, 4, 2)}

# Default is to loop over keys
for key in dd:
    print(key)
```


```{python}
#| scrolled: true
# Loop over values
for e in dd.values():
    print(e)
```

```{python}
# Loop over items (key, value) pairs
for key, val in dd.items():
    print(key, val)
```

```{python}
for t in dd.items():
    print(t)
```

## Comprehensions

You can construct a `list`, `dict`, `set` and others using the **comprehension** syntax

**`list` comprehension**

```{python}
print(colors)
print(peoples)

```

```{python}
l = []
for p, c in zip(peoples, colors):
    if len(c)<=4 :
        l.append(p)
print(l)
```

```{python}


# The list of people with favorite color that has no more than 4 characters

[people for color, people in zip(colors, peoples) if len(color) <= 4]
```

**`dict` comprehension**

```{python}
#| scrolled: true
{people: color for color, people in zip(colors, peoples) if len(color) <= 4}
```

```{python}
#| slideshow: {slide_type: fragment}
# Allows to build a dict from two lists (for keys and values)
{key: value for (key, value) in zip(peoples, colors)}
```

```{python}
# But it's simpler (so better) to use
dict(zip(peoples, colors))
```

Something very convenient is `enumerate`

```{python}
for i, color in enumerate(colors):
    print(i, color)
```

```{python}
list(enumerate(colors))
```

```{python}
dict(enumerate(s))
```

```{python}
#| slideshow: {slide_type: fragment}
print(dict(enumerate(s)))
```

```{python}
s = 'Hey everyone'
{c: i for i, c in enumerate(s)}
```

## About functional programming

We can use `lambda` to define **anonymous** functions, and use them in the `map` and `reduce` functions

```{python}
#| scrolled: true
square = lambda x: x ** 2
square(2)
```

```{python}
type(square)
```

```{python}
dir(square)
```

```{python}
s = "a"
```

```{python}
try:
    square("a")
except TypeError:
    print("TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'")
```

```{python}
sum2 = lambda a, b: a + b
print(sum2('Hello', ' world'))
print(sum2(1, 2))
```

Intended for short and one-line function. 

More complex functions use `def` (see below)

## Exercise

Print the squares of even numbers between 0 et 15

1. Using a list comprehension as before
2. Using `map`

::: {.content-visible when-profile='solution'} 

```{python}
#| slideshow: {slide_type: fragment}
# Answer to 1.
[i ** 2 for i in range(15) if i % 2 == 0]
```

```{python}
#| slideshow: {slide_type: fragment}
# Answer to 2. 
list(map(lambda x: x ** 2, range(0, 15, 2)))
```

**Remark**. We will see later why we need to use `list` above

```{python}
map(lambda x: x ** 2, range(0, 15, 2))
```

Now, to get the sum of these squares, we can use `sum`

```{python}
#| scrolled: true
sum(map(lambda x: x ** 2, range(0, 15, 2)))
```

We can also use `reduce` (not a good idea here, but it's good to know that it exists)

```{python}
from functools import reduce

reduce(lambda a, b: a + b, map(lambda x: x ** 2, range(0, 15, 2)))
```

There is also something that can be useful in `functool` called `partial`

It allows to **simplify** functions by freezing some arguments

```{python}
#| slideshow: {slide_type: '-'}
from functools import partial

def mult(a, b):
    return a * b

double = partial(mult, b=2)
double(2) 
```

:::

## Brain-teasing

What is the output of

```{python}
#| eval: false

from functools import reduce 

reduce(
    lambda a, b: a + b[0] * b[1], 
    enumerate('abcde'), 'A'
)
```

::: {.content-visible when-profile='solution'} 
 
```{python}
#| scrolled: true
#| slideshow: {slide_type: fragment}
reduce(
    lambda a, b: a + b[0] * b[1],
    enumerate('abcde'), 'A')
```

This does the following

```{python}
list(enumerate('abcde'))
```

```{python}
((((('A' + 0 * 'a') + 1 * 'b') + 2 * 'c') + 3 * 'd') + 4 * 'e')
```

:::


# Generators

```{python}
#| slideshow: {slide_type: subslide}
import sys
import matplotlib.pyplot as plt
%matplotlib inline
```

```{python}
plt.figure(figsize=(6, 6))
plt.plot([sys.getsizeof(list(range(i))) for i in range(10000)], lw=3)
plt.plot([sys.getsizeof(range(i)) for i in range(10000)], lw=3)
plt.xlabel('Number of elements (value of i)', fontsize=14)
plt.ylabel('Size (in bytes)', fontsize=14)
_ = plt.legend(['list(range(i))', 'range(i)'], fontsize=16)
```



## Why generators ?

The memory used by `range(i)` does not scale linearly with `i`

What is happening ?

- `range(n)` does not allocate a list of `n` elements ! 
- It **generates on the fly** the list of required integers
- We say that such an object behaves like a **generator** in `Python`
- Many things in the `Python` standard library behaves like this


**Warning.** Getting the real memory footprint of a `Python` object is difficult. 
Note that `sizeof` calls the `__sizeof__` method of `r`, which does not give in general the actual memory footprint used by an object. But nevermind here.

The following computation has no memory footprint:

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
sum(range(10**8))
```

```{python}
#| scrolled: true
map(lambda x: x**2, range(10**7))
```

`map` does not return a `list` for the same reason

```{python}
sum(map(lambda x: x**2, range(10**6)))
```

## Generator expression

Namely generators defined through comprehensions.
Just replace `[]` by `()` in the comprehension.

A generator can be iterated on only **once**

```{python}
range(10)
```

```{python}
carres = (i**2 for i in range(10))
```

```{python}
carres
```

```{python}
for c in carres:
    print(c)
```

```{python}
for i in range(4):
    for j in range(3):
        print(i, j)
```

```{python}
from itertools import product

for t in product(range(4), range(3)):
    print(t)
```

```{python}
from itertools import product

gene = (i + j for i, j in product(range(3), range(3)))
gene
```

```{python}
print(list(gene))
print(list(gene))
```

## `yield`

Something very powerful. 

```{python}
def startswith(words, letter):
    for word in words:
        if word.startswith(letter):
            yield word
```

Object `startswith` is not a function but a *generator*.  This comes from the presence of keyword `yield` in the body of the function. 


```{python}
words = [
    'Python', "is", 'awesome', 'in', 'particular', 'generators', 
    'are', 'really', 'cool', 'indeed'
]
```

```{python}
wg = startswith(words, "i")

type(wg)
```

The generator can be used in a list comprehension.
```{python}
list(word for word in wg)
```


But also with a `for` loop

```{python}
#| scrolled: true
for word in startswith(words, letter='a'):
    print(word)
```

```{python}
it = startswith(words, letter='a')
```

```{python}
type(it)
```

```{python}
next(it)
```

```{python}
next(it)
```

```{python}
try:
    next(it)
except StopIteration:
    print("StopIteration exception!")
```


## Exercise

Build a generator for Wallis approximations of $\pi$. The generator with output 
$$
2 \prod_{i=1}^{10^k} \frac{4i^2}{4i^2-1}
$$
for $k=1, 2, \ldots$

Use the generator to plot the approximation error of Wallis approximations of $\pi$ as a function of the number of iterations. Use logarithmic scales, on both axes.  

::: {.content-visible unless-profile="solution"}

```{python}
# your code
```

:::


::: {.content-visible when-profile="solution"}

```{python}
def wallis_gen():
    pi_approx, i = 2, 1

    yield i, pi_approx
    while True:
        inext = 10 * i
        while i < inext:
            pi_approx, i = pi_approx * 4 * i ** 2 / (4 * i ** 2 - 1), i + 1
        else:
            yield i, pi_approx        

```

```{python}
g = wallis_gen()

l = [next(g) for i in range(9)]
```

```{python}
import numpy as np

x_array, y_array = np.array(list(zip(*l)))
x_array = np.log10(x_array)
y_array =np.log10(np.pi-y_array)
```


```{python}
#| fig-cap: Convergence of Wallis approxmation 
plt.figure(figsize=(6, 6))
plt.plot(x_array, y_array, lw=2)
plt.xlabel('Number of iterations', fontsize=14)
plt.ylabel('Wallis approximation error', fontsize=14)
plt.grid(True, alpha=0.3)
plt.show()
```
:::


See [@ramalho_fluent_2022, Chapter 17, Iterators, Generators, and Classic Coroutines] 

# A glimpse at the ` collections` module

(This is where the good stuff hides)

```{python}
#| slideshow: {slide_type: subslide}
texte = """             
Bonjour,
Python c'est super.
Python ca a l'air quand même un peu compliqué.
Mais bon, ca a l'air pratique.
Peut-être que je pourrais m'en servir pour faire des trucs super.
"""
texte
```

```{python}
print(texte)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
# Some very basic text preprocessing 
new_text = (
    texte
    .strip()
    .replace('\n', ' ')
    .replace(',', ' ')
    .replace('.', ' ')
    .replace("'", ' ')
)

print(new_text)
print('-' * 8)

words = new_text.split()
print(words)
```

## Exercise 

Count the number of occurences of all the words in `words`. 

Output must be a dictionary containg ``word: count``

 
```{python}
print(words)
```

::: {.content-visible when-profile='solution'} 

### Solution 1: hand-made

```{python}
#| slideshow: {slide_type: '-'}
words_counts = {}
for word in words:
    if word in words_counts:
        words_counts[word] += 1
    else:
        words_counts[word] = 1

print(words_counts)
```

:::

::: {.content-visible when-profile='solution'} 

### Solution 2: using `defaultdict`

```{python}
int()
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
from collections import defaultdict

words_counts = defaultdict(int)
for word in words:
    words_counts[word] += 1

print(words_counts)
```

- `defaultdict` can be extremely useful
- A dict with a default value: here an `int` is created (defaults to 0) if key is not found
- Allows to avoid a test

### About `defaultdict`

- the argument must be a "callable" (something that can be called)
- Beware: as soon as a key is searched, a default value is added to the `defaultdict`

```{python}
addresses = defaultdict(lambda: 'unknown')
addresses['huyen']
addresses['gaston'] = '8 place Aurelie Nemours'
print(addresses)
```

```{python}
# Somewhat nasty...
print('jean-francois' in addresses)
print(addresses['jean-francois'])
print('jean-francois' in addresses)
```

:::

::: {.content-visible when-profile='solution'} 

### Solution 3. Don't do it by hand ! Use `counter`

```{python}
#| slideshow: {slide_type: '-'}
from collections import Counter

print(dict(Counter(words)))
```

`Counter` counts the number of occurences of all objects in an iterable

**Question.** Which one do you prefer ?

- The `Counter` one right ?


**Suggestion** : query  your chatbot with a prompt like 

```
I have an iterable containing strings (says words), I want to output a dictionary with keys made of elements of my iterable and values equal to the number of occurrences of the key in the iterable. How can I do that?
```

### Morality

- When you need to do something, assume that there is a tool to do it directly 

- If you can't find it, ask `google`, `stackoverflow`, or your favorite AIs

- Otherwise, try to do it as simply as possible

:::

## Exercise 

Compute the number of occurences AND the length of each word in `words`.

Output must be a dictionary containing ``word: (count, length)``


::: {.content-visible when-profile='solution'} 

### Solution

```{python}
#| slideshow: {slide_type: '-'}
from collections import Counter

{word: (count, len(word)) for word, count in Counter(words).items()}
```

## The `namedtuple`

There is also the `namedtuple`. It's a `tuple` but with *named* attributes

```{python}
from collections import namedtuple

Jedi = namedtuple('Jedi', ['firstname', 'lastname', 'age', 'color'])
yoda = Jedi('Minch', 'Yoda', 900, 'green')
yoda
```

```{python}
#| scrolled: true
yoda.firstname
```

```{python}
yoda[1]
```

**Remark.** A better alternative since `Python 3.7` is dataclasses. We will talk about it later

:::

# I/O, reading and writing files

Next, put a text file `miserables.txt` in the folder containing 
this notebook.  If it is not there, the next cell downloads it, if is it there, then we do nothing.

```{python}
#| scrolled: true
import requests
import os

# The path containing your notebook
path_data = './data/'
# The name of the file
filename = 'Une-tenebreuse-affaire.txt'
```

```{python}
if os.path.exists(os.path.join(path_data, filename)):
    print('The file %s already exists.' % os.path.join(path_data, filename))
else:
    url = 'https://s-v-b.github.io/IFEBY310/data/Une-tenebreuse-affaire.txt'
    r = requests.get(url)
    with open(os.path.join(path_data, filename), 'wb') as f:
        f.write(r.content)
    print('Downloaded file %s.' % os.path.join(path_data, filename))
```

```{python}
#| scrolled: true
ls -alh  data
```

```{python}
# !rm -f miserables.txt
```

```{python}
#| scrolled: true
os.path.join(path_data, filename)
```

In `jupyter` and `ipython` you can run terminal command lines using `!`

Let's count number of lines and number of words with the `wc` command-line tool (linux or mac only, don't ask me how on windows)

```{python}
#| slideshow: {slide_type: '-'}
# Lines count
!wc -l ./data/Une-tenebreuse-affaire.txt
```

```{python}
# Word count
!wc -w ./data/Une-tenebreuse-affaire.txt
```

## Exercise

Count the number of occurences of each word in the text file `Une-tenebreuse-affaire.txt`.
We use a `open` *context* and the `Counter` from before.

::: {.content-visible when-profile='solution'} 

### Solution

```{python}
#| slideshow: {slide_type: '-'}
from collections import Counter

counter = Counter()

with open(os.path.join(path_data, filename), encoding='utf8') as f:
    for line_idx, line in enumerate(f):
        line = line.strip().replace('\n', ' ')\
            .replace(',', ' ')\
            .replace('.', ' ')\
            .replace('»', ' ')\
            .replace('-', ' ')\
            .replace('!', ' ')\
            .replace('(', ' ')\
            .replace(')', ' ')\
            .replace('?', ' ').split()

        counter.update(line)
```



```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
counter
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
counter.most_common(500)
```

:::


## Contexts 

- A *context* in Python is something that we use with the `with` keyword.

- It allows to deal automatically with the opening and the closing of the file.

Note the for loop:
```{.python}
for line in f:
    ...
```
You loop directly over the lines of the open file from **within** the `open` context

## About `pickle`

You can save your computation with `pickle`. 

- `pickle` is a way of saving **almost anything** with Python.
- It serializes the object in a binary format, and is usually the simplest and fastest way to go.

```{python}
import pickle as pkl

pkl_fpath = os.path.join(path_data, filename.replace('txt','pkl'))
# Let's save it
with open(pkl_fpath, 'wb') as f:
    pkl.dump(counter, f)

# And read it again
with open(pkl_fpath, 'rb') as f:
    counter = pkl.load(f)
```

```{python}
#| scrolled: true
counter.most_common(10)
```

# Defining functions

You **must** use function to order and reuse code

## Function definition

Function blocks must be indented as other control-flow blocks.

```{python}
def test():
    return 'in test function'

test()
```

## Return statement

Functions can *optionally* return values.
By default, functions return ``None``.

The syntax to define a function:

- the ``def`` keyword;
- is followed by the function's **name**, then
- the arguments of the function are given between parentheses followed by a colon
- the function body;
- and ``return object`` for optionally returning values.

```{python}
None is None
```

```{python}
def f(x):
    return x + 10
f(20)
```

A function that returns several elements returns a `tuple`

```{python}
def f(x):
    return x + 1, x + 4

f(5)
```

```{python}
type(f)
```

```{python}
f.truc = "bonjour"
```

```{python}
type(f(5))
```

## Parameters

Mandatory parameters (positional arguments)

```{python}
def double_it(x, /):
    return x * 2

double_it(2)
```

```{python}
try:
    double_it()
except TypeError:
    print("TypeError: double_it() missing 1 required positional argument: 'x'")
```

Optimal parameters

```{python}
#| slideshow: {slide_type: '-'}
def double_it(x=2):
    return x * 2

double_it()
```

```{python}
double_it(3)
```

```{python}
#| slideshow: {slide_type: subslide}
def f(x ,  y=2, z=10):
    print(x, '+', y, '+', z, '=', x + y + z)
```

```{python}
f(5)
```

```{python}
f(5, -2)
```

```{python}
f(5, -2, 8)
```

```{python}
f(z=5, x=-2, y=8)
```

To avoid the possibility  of passing a positional argument as a keyword argument, there exists a special construct:

```{python}
# %%
# %%
def f(x , /,  y=2, z=10):
    print(x, '+', y, '+', z, '=', x + y + z)
```

```{python}
try:
    f(z=5, x=10, y=3)
except TypeError:
    print("TypeError: f() got some positional-only arguments passed as keyword arguments: 'x'")
```

## Argument unpacking and keyword argument unpacking

You can do stuff like this, using unpacking `*` notation

```{python}
a, *b, c = 1, 2, 3, 4, 5
a, b, c
```

If we are just interested in the first and last item 
```{python}
first, *_, last =   1, 2, 3, 4, 5
first, last
```


Back to function `f` you can unpack a `tuple` as positional arguments


```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
tt = (1, 2, 3)
f(*tt)
```

We can also use dictionnary unpacking for keywords parameters.

```{python}
dd = {'y': 10, 'z': -5}
```

```{python}
f(3, **dd)
```

We can use both

```{python}
#| slideshow: {slide_type: subslide}
def g(x, z, y, t=1, u=2):
    print(x, '+', y, '+', z, '+', t, '+', 
          u, '=', x + y + z + t + u)
```

```{python}
#| scrolled: true
tt = (1, -4, 2)
dd = {'t': 10, 'u': -5}
g(*tt, **dd)
```

## The prototype of all functions in `Python`

```{python}
#| slideshow: {slide_type: '-'}
def f(*args, **kwargs):
    print('args=', args)
    print('kwargs=', kwargs)

f(1, 2, 'truc', lastname='lagaffe', firstname='gaston')
```

- Uses `*` for **argument unpacking** and `**` for **keyword argument unpacking**
- The names `args` and `kwargs` are a convention, not mandatory 
- (but you are fired if you name these arguments otherwise)

```{python}
#| slideshow: {slide_type: fragment}
# How to get fired
def f(*aaa, **bbb):
    print('args=', aaa)
    print('kwargs=', bbb)
f(1, 2, 'truc', lastname='lagaffe', firstname='gaston')    
```

**Remark**. A function is a regular an object... you can add attributes on it !

```{python}
f.truc = 4
```

```{python}
#| scrolled: true
f(1, 3)
```

```{python}
f(3, -2, y='truc')
```

# Object-oriented programming (OOP)

Python supports object-oriented programming (OOP). The goals of OOP are:

- to organize the code, and
- to re-use code in similar contexts.

Here is a small example: we create a `Student` class, which is an object
gathering several custom functions (called *methods*) and variables 
(called *attributes*).

```{python}
#| slideshow: {slide_type: subslide}
class Student(object):

    def __init__(self, name, birthyear, major='computer science'):
        self.name = name
        self.birthyear = birthyear
        self.major = major

    def __repr__(self):
        return "Student(name='{name}', birthyear={birthyear}, major='{major}')"\
                .format(name=self.name, birthyear=self.birthyear, major=self.major)

anna = Student('anna', 1987)
anna
```

The `__repr__` is what we call a 'magic method' (or 'dunder method') in Python, that allows 
to display an object as a string easily. There is a very large number of such magic methods.
There are used to implement **interfaces**

## Exercise 

Add a `age` method to the Student class that computes the age of the student. 
- You  can (and should) use the `datetime` module. 
- Since we only know about the birth year, let's assume that the day of the birth is January, 1st.

::: {.content-visible unless-profile="solution"}

```{python}
from datetime import datetime

# your code here
```

:::

::: {.content-visible when-profile='solution'} 

### Correction

```{python}
from datetime import datetime

class Student(object):

    def __init__(self, name, birthyear, major='computer science'):
        self.name = name
        self.birthyear = birthyear
        self.major = major

    def __repr__(self):
        return "Student(name='{name}', birthyear={birthyear}, major='{major}')"\
                .format(name=self.name, birthyear=self.birthyear, major=self.major)

    def age(self):
        return datetime.now().year - self.birthyear
        
anna = Student('anna', 1987)
anna.age()
```

:::


## Properties

We can make methods look like attributes using **properties**, as shown below

```{python}
#| scrolled: true
class Student(object):

    def __init__(self, name, birthyear, major='computer science'):
        self.name = name
        self.birthyear = birthyear
        self.major = major

    def __repr__(self):
        return "Student(name='{name}', birthyear={birthyear}, major='{major}')"\
                .format(name=self.name, birthyear=self.birthyear, major=self.major)

    @property
    def age(self):
        return datetime.now().year - self.birthyear
        
anna = Student('anna', 1987)
anna.age
```

Here `property` is a *decorator* 

```{python}
maria = eval(repr(anna))
```

```{python}
id(maria), id(anna)
```

`maria` and `anna` are different objects, eventhough they have the same attributes (check with `maria.__dict__`)


## Inheritance 

A `MasterStudent` is a `Student` with a new extra mandatory `internship` attribute

```{python}
"%d" % 2
```

```{python}
x = 2

f"truc {x}"
```

```{python}
class MasterStudent(Student):
    
    def __init__(self, name, birthyear, internship, major='computer science'):
        # Student.__init__(self, name, age, major)
        Student.__init__(self, name, birthyear, major)
        self.internship = internship

    def __repr__(self):
        return f"MasterStudent(name='{self.name}', internship={self.internship}, birthyear={self.birthyear}, major={self.major})"
    
MasterStudent('spirou', 2002, 'pwc')
```

```{python}
class MasterStudent(Student):
    
    def __init__(self, name, birthyear, internship, major='computer science'):
        # Student.__init__(self, name, age, major)
        Student.__init__(self, name, birthyear, major)
        self.internship = internship

    def __repr__(self):
        return "MasterStudent(name='{name}', internship='{internship}'" \
               ", birthyear={birthyear}, major='{major}')"\
                .format(name=self.name, internship=self.internship,
                        birthyear=self.birthyear, major=self.major)
    
spirou = MasterStudent('spirou', 1996, 'pwc')
```

```{python}
spirou.__dict__
```

```{python}
spirou.birthyear
```

```{python}
spirou.__dict__["birthyear"]
```

## Monkey patching

- Classes in `Python`  are `objects` and actually `dict`s under the hood...
- Therefore classes are objects that can be changed on the fly

```{python}
class Monkey(object):
    
    def __init__(self, name):
        self.name = name

    def describe(self):
        print("Old monkey %s" % self.name)

def patch(self):
    print("New monkey %s" % self.name)

monkey = Monkey("Baloo")
monkey.describe()

Monkey.describe = patch
monkey.describe()
```

```{python}
monkeys = [Monkey("Baloo"), Monkey("Super singe")]

monkey_name = monkey.name

for i in range(1000):    
    monkey_name
```


## Data classes

Since `Python 3.7` you can use a dataclass for this

Does a lot of work for you (produces the `__repr__` among many other things for you)

This is another use *decorators*.

```{python}
from dataclasses import dataclass
from datetime import datetime 

@dataclass
class Student(object):
    name: str
    birthyear: int
    major: str = 'computer science'

    @property
    def age(self):
        return datetime.now().year - self.birthyear
        
anna = Student(name="anna", birthyear=1987)
anna
```

```{python}
print(anna.age)
```

# Most common mistakes

- Let us wrap this up with the most common mistakes with `Python`

First, best way to learn and practice:

- Start with the official tutorial https://docs.python.org/fr/3/tutorial/index.html

- Look at https://python-3-for-scientists.readthedocs.io/en/latest/index.html

- Continue with the documentation at https://docs.python.org/fr/3/index.html and work!

## Using a mutable value as a default value

```{python}
def foo(bar=[]):
    bar.append('oops')
    return bar

print(foo())
print(foo())
print(foo())

print('-' * 8)
print(foo(['Ah ah']))
print(foo([]))
```

```{python}
print(foo.__defaults__)
foo()
print(foo.__defaults__)
```

- The default value for a function argument is evaluated once, *when the function is defined*
- `the` bar argument is initialized to its default (i.e., an empty list) only when foo() is first defined
- successive calls to `foo()` (with no  `bar` argument specified) use the same list!

One should use instead

```{python}
#| slideshow: {slide_type: '-'}
def foo(bar=None):
    if bar is None:
        bar = []
    bar.append('oops')
    return bar

print(foo())
print(foo())
print(foo())
print(foo(['OK']))
```

```{python}
print(foo.__defaults__)
foo()
print(foo.__defaults__)
```

No problem with immutable types

```{python}
def foo(bar=()):
    bar += ('oops',)
    return bar

print(foo())
print(foo())
print(foo())
```

```{python}
print(foo.__defaults__)
```

## Class attributes VS object attributes

```{python}
class A(object):
    x = 1

    def __init__(self):
        self.y = 2

class B(A):
    def __init__(self):
        super().__init__()

class C(A):
    def __init__(self):
        super().__init__()

a, b, c = A(), B(), C()
```

```{python}
#| scrolled: true
print(a.x, b.x, c.x)
print(a.y, b.y, c.y)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
a.y = 3
print(a.y, b.y, c.y)
```

```{python}
#| scrolled: true
a.x = 3  # adds  a new object attribute named x in object a
print(a.x, b.x, c.x)
```

```{python}
#| scrolled: true
A.x = 4 # Changes the class attribute x of class A
print(a.x, b.x, c.x)
```

- Attribute `x` is not an **attribute** of `b` nor `c`
- It is also not a **class attribute** of classes `B` and `C`
- So, it is is looked up in the base class `A`, which contains a **class attribute** `x`

Classes and objects contain a hidden `dict` to store their attributes, and are accessed following a method resolution order (MRO)

```{python}
#| slideshow: {slide_type: '-'}
a.__dict__, b.__dict__, c.__dict__
```

```{python}
A.__dict__, B.__dict__, C.__dict__
```

This can lead to **nasty** errors when using class attributes: learn more about this

## Fiddling with Python scoping rules

```{python}
try:
    ints += [4]
except NameError:
    print("NameError: name 'ints' is not defined")
```


```{python}
ints = [1]

def foo1():
    ints.append(2)
    return ints

def foo2():
    ints += [2]
    return ints
```

```{python}
foo1()
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}

try:    
    foo2()
except UnboundLocalError as inst:
    print(inst)
```

### What the hell ?

An assignment to a variable in a scope assumes that the variable is *local* to that scope and shadows any similarly named variable in any outer scope

```{.python}
ints += [2]
```
means

```{.python}
ints = ints + [2]
```

which is an *assigment*: `ints` must be defined in the local scope, but it is not, while

```{.python}
ints.append(2)
```

is not an *assignemnt*

In `foo1` there is no local variable, whereas in `foo2`, `ints` is a local variable (which is not associated with a value).
 
```{python}
print(
    foo1.__code__.co_varnames,
    foo2.__code__.co_varnames
)
```
[See @ramalho_fluent_2022, Chapter 9, Decorators and Closures]


## Exercice 

Use `global` declaration to fix `foo2`


::: {.content-visible unless-profile="solution"}

```{python}
# your code 
```
:::


::: {.content-visible when-profile="solution"}

```{python}
ints = [1]

def foo2():
    global ints
    ints += [2]
    return ints
```


```{python}
for i in range(5):
    foo2()
else:
    print(ints)
```


Using global objects is seldom a good idea.

:::


## Modify a `list` while iterating over it

```{python}
odd = lambda x: bool(x % 2)
numbers = list(range(10))

try:
  for i in range(len(numbers)):
      if odd(numbers[i]):
          del numbers[i]
except IndexError as inst:
    print(inst)
```

What are we trying to do here? Ask an AI to review the `for ...:` block inside the `try: ... except ...:` block.  

Typically an example where one should use a list comprehension

```{python}
[number for number in numbers if not odd(number)]
```

Look at package `itertools` for off the shelf solutions.

::: {.content-visible when-profile="solution"}

```{python}
from itertools import filterfalse

list(filterfalse(odd, numbers))
```

Package `itertools` provides a collection of functions that take an *iterable* like `numbers` as argument and return 
another *iterable*.

```{python}
# %%
from collections.abc import Iterable

isinstance(
    filterfalse(lambda x : x % 2, range(10)), 
    Iterable)
```

:::


## No docstrings

Accept to spend time to write clean docstrings (look at `numpydoc` style)

```{python}
def create_student(name, birthyear, address, major='computer science'):
    """Add a student in the database
    
    Parameters
    ----------
    name: `str`
        Name of the student
    
    birthyear: `int`
        birthyear of the student
    
    address: `str`
        Address of the student
    
    major: `str`, default='MIDS'
        The major chosen by the student
    
    Returns
    -------
    output: `Student`
        A fresh student
    """
    pass
```

```{python}
create_student('Duduche', 1938, 'Chalons')
```


```{python}
?create_student
```


This task can be facilitated by AI tools. Here follows an automatically generated docstring.


```{python}
from dataclasses import dataclass
from datetime import datetime 

@dataclass
class Student(object):
    """A dataclass representing a student with personal information.
    
    Attributes
    ----------
    name: `str`
        Name of the student
    
    birthyear: `int`
        Birth year of the student
    
    major: `str`, default='computer science'
        The major field of study chosen by the student
    
    age: `int`, property
        Calculated age based on current year minus birthyear
        (read-only property)
    
    Examples
    --------
    >>> anna = Student(name="anna", birthyear=1987)
    >>> print(anna.name)
    anna
    >>> print(anna.age)
    37
    """
    name: str
    birthyear: int
    major: str = 'computer science'

    @property
    def age(self):
        return datetime.now().year - self.birthyear
        
anna = Student(name="anna", birthyear=1987)
anna
```

## Not using available methods and/or the simplest solution

```{python}
dd = {'gaston': 1234, 'gael': 4567, 'gontran': 891011}

# Bad
for key in dd.keys():
    print(key, dd[key])

print('-' * 8)

# Good
for key, value in dd.items():
    print(key, value)
```

```{python}
#| slideshow: {slide_type: subslide}
colors = ['black', 'yellow', 'brown', 'red', 'pink']

# Bad
for i in range(len(colors)):
    print(i, colors[i])

print('-' * 8)

# Good
for i, color in enumerate(colors):
    print(i, color)
```

## Not using the standard library 

While it's *always* better than a hand-made solution

```{python}
list1 = [1, 2]
list2 = [3, 4]
list3 = [5, 6, 7]

for a in list1:
    for b in list2:
        for c in list3:
            print(a, b, c)
```

```{python}
#| slideshow: {slide_type: subslide}
from itertools import product

for a, b, c in product(list1, list2, list3):
    print(a, b, c)
```

Note that `product(list1, list2, list3)` returns an Iterable. `product` takes as argument an arbitrary list of
Iterable and returns an Iterable over all tuples that can be built from the iterables  in the argument list.

Check the [code](https://docs.python.org/3/library/itertools.html#itertools.product)

```{python}
def my_3fold_product(list1, list2, list3):
    for a in list1:
        for b in list2:
            for c in list3:
                yield a, b, c
```

```{python}

```

# The end !

[@ramalho_fluent_2022] is both an enlightened presentation of Python, it is also a mine of elegant and safe programming tricks.
