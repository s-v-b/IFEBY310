---
title: "Introduction to `numpy`"
date: "`r Sys.Date()"

jupyter: python3

engine: jupyter
---


[`NumPy`](https://numpy.org) is the fundamental package for scientific computing with Python. It contains among other things:

- a powerful [N-dimensional array object](https://numpy.org/doc/stable/user/basics.indexing.html)
- (sophisticated) [broadcasting functions](https://numpy.org/doc/stable/user/basics.broadcasting.html)
- tools for integrating C/C++ and Fortran code
- useful [linear algebra](https://numpy.org/doc/stable/reference/routines.linalg.html), [Fourier transform](https://numpy.org/doc/stable/user/basics.indexing.html), and [random generation capabilities](https://numpy.org/doc/stable/reference/random/index.html)

Besides its obvious scientific uses, `NumPy` can also be used as an efficient multi-dimensional container for general data. Arbitrary data-types can be defined. This allows `NumPy` to seamlessly and speedily integrate with a wide variety of databases.

Library documentation: <a>http://numpy.org/</a>


## The base `numpy.array` object

```{python}
#| slideshow: {slide_type: subslide}
#| label:  setup
import numpy as np

# declare a vector using a list as the argument
v = np.array([1, 2.0, 3, 4])
v
```

```{python}
list([1, 2.0, 3, 4])
```

```{python}
type(v)
```

```{python}
#| scrolled: true
v.shape
```

```{python}
v.ndim
```

```{python}
#| scrolled: true
v.dtype is float
```

```{python}
v.dtype 
```

```{python}

np.uint8 is int
```

::: {.callout-tip collapse="true"} 

Use copilot or any AI to *explain* to understand the chunks:

>  The `np.uint8` is a data type in NumPy, representing an unsigned 8-bit integer, which can store values from 0 to 255. The `int` type is the built-in integer type in Python, which can represent any integer value without a fixed size limit.

:::

```{python}
try:
    np.array([2**120, 2**40], dtype=np.int64)
except OverflowError:
    print('OverflowError: Python int too large to convert to C long')
```

```{python}
np.uint16 is int 
```

```{python}
np.uint32  is int
```

```{python}
#| slideshow: {slide_type: subslide}
w = np.array([1.3, 2, 3, 4], dtype=np.int64)
w
```

```{python}
w.dtype
```

```{python}
#| slideshow: {slide_type: subslide}
a = np.arange(100)
```

```{python}
type(a)
```

```{python}
np.array(range(100))
```

```{python}
a
```

```{python}
a.dtype
```

```{python}
-3 * a ** 2
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
a[42] = 13
```

```{python}
a[42] = 1025
```

```{python}
np.info(np.int16)
```

```{python}
np.int16
```

```{python}
#| scrolled: true
dict(enumerate(a))
```

```{python}
a + 1
```

```{python}
b = a + 1
b
```

```{python}
a is b
```

```{python}
#| slideshow: {slide_type: subslide}
f = id(a)
a += 1
f, id(a)
```

```{python}
a
```

```{python}
b
```

::: {.callout-warning}

Beware of the dimensions: a 1D array is not the same as a 2D array with 1 column

::: 



```{python}
#| slideshow: {slide_type: '-'}
a1 = np.array([1, 2, 3])
print(a1, a1.shape, a1.ndim)
```

```{python}
a2 = np.array([1, 2, 3])
print(a2, a2.shape, a2.ndim)
```


[More on NumPy quickstart](https://numpy.org/devdocs/user/quickstart.html)

::: {.callout-note title="Question" collapse="true"}

List the data attributes and methods (the attributes) of class `numpy.ndarray`. 
You may use function `dir()` and filter the result using 
methods for objects of class `string`. 

:::

## Matrix multiplication

```{python}
#| scrolled: true
a2.dot(a1) # inner product 
```

```{python}
( 
    np.array([a2])
        .transpose() # column vector
        .dot(np.array([a1]))
) # column vector multiplied by row vector
```

```{python}
(
    np.array([a2])
    .transpose()#.shape
)
```

```{python}
(
    a2.reshape(3,1)  # all explicit
      .dot(a1.reshape(1, 3))
)
```

```{python}
#| slideshow: {slide_type: subslide}
# Declare a 2D array using a nested list as the constructor argument
M = np.array([[1,2], 
              [3,4], 
              [3.14, -9.17]])
M
```

```{python}
M.shape, M.size
```

```{python}
#| scrolled: true
M.ravel(), M.ndim, M.ravel().shape
```

```{python}
#| slideshow: {slide_type: subslide}
# arguments: start, stop, step
x = (
     np.arange(12)
       .reshape(4, 3)
)
x
```

```{python}
y = np.arange(3).reshape(3,1)

y
```

```{python}
x @ y, x.dot(y)
```

::: {.callout-note}


:::

## Generating arrays

```{python}
np.linspace(0, 10, 51)  # meaning of the 3 positional parameters ? 
```

```{python}
#| slideshow: {slide_type: '-'}
np.logspace(0, 10, 11, base=np.e), np.e**(np.arange(11))
```

```{python}
#| slideshow: {slide_type: subslide}
import matplotlib.pyplot as plt

# Random standard Gaussian numbers
fig = plt.figure(figsize=(8, 4))
wn = np.random.randn(1000)
bm = wn.cumsum()

plt.plot(bm, lw=3)
```

```{python}
#| slideshow: {slide_type: subslide}
np.diag(np.arange(10))
```

```{python}
#| slideshow: {slide_type: '-'}
zozo = np.zeros((10, 10), dtype=np.float32)
zozo
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
zozo.shape
```

Coercing to another `numpy` type

```{python}
zozo.astype(np.short)[:5, :**5**]
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
print(M)
```

```{python}
#| scrolled: true
M[1, 1]
```

```{python}
#| slideshow: {slide_type: '-'}
# assign new value
M[0, 0] = 7
M[:, 0] = 42
M
```

```{python}
M
```

```{python}
#| scrolled: true
# Warning: the next m is a **view** on M. 
# One again, no copies unless you ask for one!
m = M[0, :]
m
```

```{python}
m[:] = 3.14
M
```

```{python}
m[:] = 7
M
```

# Slicing

```{python}
#| slideshow: {slide_type: subslide}
# slicing works just like with anything else (lists, etc.)
A = np.array([1, 2, 3, 4, 5])
print(A)
print(A[::-1])
print(A[::2])
print(A[:-1:2])
```

```{python}
[[n + m * 10 for n in range(5)] for m in range(5)]
```

```{python}
A = np.array([[n + m * 10 for n in range(5)] for m in range(5)])
A
```

```{python}
#| slideshow: {slide_type: subslide}
print(A[1:4])
```

```{python}
m = A[:, 1:4]
```

```{python}
m[1, 1] = 123
```

```{python}
A
```

```{python}
A[1]
```

```{python}
A[:, 1]
```

```{python}
A[:, ::-1]
```

```{python}
#| slideshow: {slide_type: subslide}
print(A)
```

```{python}
row_indices = np.array([1, 2, 4])
print(A[row_indices])
```

```{python}
A[:, row_indices]
```

Another way is through masking with an array of `bool`s


```{python}
#| slideshow: {slide_type: '-'}
# index masking
B = np.arange(5)
row_mask = np.array([True, False, True, False, False])
print(B)
print(B[row_mask])
```

```{python}
A, A[row_mask] , A[:,row_mask]
```

## Copies

Don't forget that `python` *does not make copies unless told to do so* (same as with any mutable type)

If you are not careful enough, this typically leads to a *lot of errors* and to being fired !!

```{python}
#| slideshow: {slide_type: '-'}
y = x = np.arange(6)
x[2] = 123
y
```

```{python}
x is y
```

```{python}
#| slideshow: {slide_type: subslide}
# A real copy
y = x.copy()
x is y 
```

```{python}
# Or equivalently (but the one above is better...)
y = np.copy(x)
```

```{python}
x[0] = -12
print(x, y, x is y)
```

To put values of x in y (copy values into an **existing** array) use  

```{python}
x = np.random.randn(10)
x, id(x)
```

```{python}
x.fill(2.78)   # in place. 
x, id(x)
```

```{python}
x[:] = 3.14  # x.fill(3.14)  can. be chained ...
x, id(x)
```

```{python}
x[:] = np.random.randn(x.shape[0])
x, id(x)
```

```{python}
y = np.empty(x.shape)  # how does empty() work ?
y, id(y)
```

```{python}
y = x
y, id(y), id(x), y is x
```

::: {.callout-warning}

### Final warning

:::

In the next line you copy the values of `x` into an existing array `y` (of same size...)

```{python}
#| slideshow: {slide_type: '-'}
y = np.zeros(x.shape)
y[:] = x
y, y is x, np.all(y==x)
```

While in the next line, you are aliasing, you are giving a new name `y` to the object named `x` (you should **never, ever** write something like this)

```{python}
#| slideshow: {slide_type: '-'}
y = x
y is x
```


## Miscellanea

### Non-numerical values

A `numpy` array can contain other things than numeric types

```{python}
#| slideshow: {slide_type: '-'}
arr = np.array(['Labore', 'neque', 'ipsum', 'ut', 'non', 'quiquia', 'dolore.'])
arr, arr.shape, arr.dtype
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
# arr.sum()
```

```{python}
#| slideshow: {slide_type: subslide}
"_".join(arr)
```

```{python}
#| slideshow: {slide_type: fragment}
arr.dtype
```

## A matrix is no 2D array in `numpy`

So far, we have only used `array` or `ndarray` objects

The is another type: the `matrix` type

In words: **don't use it** (IMhO) and stick with arrays

```{python}
#| slideshow: {slide_type: '-'}
# Matrix VS array objects in numpy
m1 = np.matrix(np.arange(3))
m2 = np.matrix(np.arange(3))
m1, m2
```

```{python}
#| slideshow: {slide_type: fragment}
m1.transpose() @ m2, m1.shape, m1.transpose() * m2
```

```{python}
#| slideshow: {slide_type: fragment}
a1 = np.arange(3)
a2 = np.arange(3)
a1, a2
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
m1 * m2.T, m1.dot(m2.T)
```

```{python}
a1 * a2
```

```{python}
a1.dot(a2)
```

```{python}
np.outer(a1, a2)
```

::: {.callout-note}

Visit <https://numpy.org/doc/stable/reference/arrays.ndarray.html#arrays-ndarray>

:::

## Sparse matrices

```{python}
#| slideshow: {slide_type: '-'}
from scipy.sparse import csc_matrix, csr_matrix, coo_matrix
```

```{python}

probs = np.full(fill_value=1/4, shape=(4,))
probs
```

```{python}
X = np.random.multinomial(n=2, pvals=probs, size=4)   # check you understand what is going on 
X
```

```{python}
probs
```

```{python}
#| scrolled: true
X_coo = coo_matrix(X)  ## coordinate format
```

```{python}
print(X_coo)
X_coo
```

```{python}
#| slideshow: {slide_type: subslide}
X_coo.nnz    # number pf non-zero coordinates 
```

```{python}
print(X, end='\n----\n')
print(X_coo.data, end='\n----\n')
print(X_coo.row, end='\n----\n')
print(X_coo.col, end='\n----\n')
```

There is also

- `csr_matrix`: sparse rows format 
- `csc_matrix`: sparse columns format

Sparse rows is often used for machine learning: sparse features vectors

But sparse column format useful as well (e.g. coordinate gradient descent)

## Bored with decimals?

```{python}
X = np.random.randn(5, 5)
X
```

```{python}
# All number displayed by numpy (in the current kernel) are with 3 decimals max
np.set_printoptions(precision=3)
print(X)
np.set_printoptions(precision=8)
```

## Not limited to 2D!

`numpy` arrays can have any number of dimension (hence the name `ndarray`)

```{python}
X = np.arange(18).reshape(3, 2, 3)
X
```

```{python}
X.shape
```

```{python}
X.ndim
```

Visit <https://numpy.org/doc/stable/reference/arrays.ndarray.html#arrays-ndarray>

# Aggregations and statistics

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
A = np.arange(42).reshape(7, 6)
A
```

```{python}
A.sum(), 42 * 41 //2
```

```{python}
A[:, 3].mean(), np.mean (3 + np.arange(0, 42, 6))
```

```{python}
A.mean(axis=0)
```

```{python}
A.mean(axis=1)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
A[:,3].std(), A[:,3].var()
```

```{python}
A[:,3].min(), A[:,3].max()
```

```{python}
A.cumsum(axis=0)
```

```{python}
A
```

```{python}
#| scrolled: true
# sum of diagonal
A.trace()
```

# Linear Algebra

```{python}
#| slideshow: {slide_type: subslide}
A = np.arange(30).reshape(6, 5)
v1 = np.arange(0, 5)
v2 = np.arange(5, 10)
```

```{python}
A
```

```{python}
v1, v2
```

```{python}
#| slideshow: {slide_type: '-'}
v1 * v2
```

```{python}
v1.dot(v2), np.sum(v1* v2)
```

```{python}
v1.reshape(5,1) @ v2.reshape(1,5)
```

## Inner products

```{python}
#| slideshow: {slide_type: '-'}
# Inner product between vectors
print(v1.dot(v2))

# You can use also (but first solution is better)
print(np.dot(v1, v2))
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
A, v1
```

```{python}
A.shape, v1.shape
```

```{python}
# Matrix-vector inner product
A.dot(v1)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
# Transpose
A.T
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: '-'}
print(v1)
# Inline operations (same for *=, /=, -=)
v1 += 2
```

## Linear systems

```{python}
#| slideshow: {slide_type: '-'}
A = np.array([[42,2,3], [4,5,6], [7,8,9]])
b = np.array([1,2,3])
print(A, b, sep=2 * '\n')
```

```{python}
# solve a system of linear equations
x = np.linalg.solve(A, b)
x
```

```{python}
#| slideshow: {slide_type: '-'}
A.dot(x)
```

## Eigenvalues and eigenvectors

```{python}
#| slideshow: {slide_type: '-'}
A = np.random.rand(3,3)
B = np.random.rand(3,3)

evals, evecs = np.linalg.eig(A)
evals
```

```{python}
evecs
```




## Singular value decomposition (SVD)

Decomposes any matrix $A \in \mathbb R^{m \times n}$ as follows:
$$
A = U \times S \times V^\top
$$
where 
- $U$ and $V$ are orthonormal matrices (meaning that $U^\top \times U = I$ and $V^\top \times V = I$)
- $S$ is a diagonal matrix that contains the *singular* values in non-increasing order

```{python}
#| scrolled: true
print(A)
U, S, V = np.linalg.svd(A)
```

```{python}
U.dot(np.diag(S)).dot(V)
```

```{python}
A - U @ np.diag(S) @ V
```

```{python}
#| slideshow: {slide_type: subslide}
# U and V are indeed orthonormal
np.set_printoptions(precision=2)
print(U.T.dot(U), V.T.dot(V), sep=2 * '\n')
np.set_printoptions(precision=8)
```

## Exercice: the racoon SVD

- Load the racoon face picture using `scipy.misc.face()`
- Visualize the picture
- Write a function which reshapes the picture into a 2D array, and computes the best rank-r approximation of it (the prototype of the function is `compute_approx(X, r)`
- Display the different approximations for r between 5 and 100

```{python}
!pip3 install pooch
```

```{python}
#| slideshow: {slide_type: subslide}
import numpy as np
from scipy.datasets import face
import matplotlib.pyplot as plt
%matplotlib inline

X = face()
```

```{python}
type(X)
```

```{python}
#| scrolled: true
#| slideshow: {slide_type: subslide}
plt.imshow(X)
_ = plt.axis('off')
```


```{python}
n_rows, n_cols, n_channels = X.shape
X_reshaped = X.reshape(n_rows, n_cols * n_channels)
U, S, V = np.linalg.svd(X_reshaped, full_matrices=False)
```

```{python}
X_reshaped.shape
```

```{python}
X.shape
```

```{python}
plt.plot(S**2)  ## a kind of screeplot
plt.yscale("log")
```

```{python}
#| slideshow: {slide_type: subslide}
def compute_approx(X: np.ndarray, r: int):
    """Computes the best rank-r approximation of X using SVD.
    We expect X to be the 3D array corresponding to a color image, that we 
    reduce to a 2D one to apply SVD (no broadcasting).
    
    Parameters
    ----------
    X : `np.ndarray`, shape=(n_rows, n_cols, 3)
        The input 3D ndarray
    
    r : `int`
        The desired rank
        
    Return
    ------
    output : `np.ndarray`, shape=(n_rows, n_cols, 3)
        The best rank-r approximation of X
    """
    n_rows, n_cols, n_channels = X.shape
    # Reshape X to a 2D array
    X_reshape = X.reshape(n_rows, n_cols * n_channels)
    # Compute SVD
    U, S, V = np.linalg.svd(X_reshape, full_matrices=False)
    # Keep only the top r first singular values
    S[r:] = 0
    # Compute the approximation
    X_reshape_r = U.dot(np.diag(S)).dot(V)
    # Put it between 0 and 255 again and cast to integer type
    return (
        X_reshape_r
            .clip(min=0, max=255)
            .astype('int')
            .reshape(n_rows, n_cols, n_channels)
    )
```

```{python}
#| slideshow: {slide_type: subslide}
ranks = [100, 70, 50, 30, 10, 5]
n_ranks = len(ranks)
for i, r in enumerate(ranks):
    X_r = compute_approx(X, r)
    # plt.subplot(n_ranks, 1, i + 1)
    plt.figure(figsize=(5, 5))
    plt.imshow(X_r)
    _ = plt.axis('off')
    # plt.title(f'Rank {r} approximation of the racoon' % r, fontsize=16)
    plt.tight_layout()
```


::: {.callout-tip appearance="simple"}

### Variations

In the code above, we recompute the SVD of `X` for every element in list `rank`.    
In the next chunk, we compute the SVD once, and define a *generator* to generate the low rank approximations of matrix `X`. We take advantage of the fact that the SVD defines an orthonormal basis for the space of matrices. In this adapted orthonormal basis the optimal  low rank approximations of $X$ have  a sparse expansion.

:::




```{python}
def gen_rank_k_approx(X):
    """Generator for low rank 
    approximation of a matrix X using truncated SVD.

    Args:
        X (numpy.ndarray): a numerical matrix

    Yields:
        (int,numpy.ndarray): rank k and best rank-k approximation of X using truncated SVD(according to Eckart-Young theorem).
    """  
    U, S, V = np.linalg.svd(X, full_matrices=False)
    r = 0
    Y = np.zeros_like(X, dtype='float64')
    while (r<len(S)):
      Y = Y + S[r] * (U[:, r, np.newaxis] @ V[r, :, np.newaxis].T)
      r += 1
      yield r, Y
```



```{python}
g = gen_rank_k_approx(X_reshaped) 
```

```{python}
for i in range(100):
    _, Xr = next(g)
    if i % 10 ==0:  
      plt.figure(figsize=(5, 5))
      plt.imshow(
          Xr
          .clip(min=0, max=255)
          .astype('int')
          .reshape(n_rows, n_cols, n_channels)
      )
      _ = plt.axis('off')
      plt.tight_layout()
```


Visit <https://numpy.org/numpy-tutorials/content/tutorial-svd.html>


# Broadcasting


